import * as React from "react"
import type { Row } from "@tanstack/react-table"
import type { CollectionData, ColumnSchemaExtended, DataInEntry } from "../types"
import type { LanguageCode } from "../state/useDataTableMetaState"
import { entriesToLanguageObject as entriesToLanguageObjectValue } from "../utils/dataInHelpers"

type FormCallbacksParams = {
  collection: string
  locale: LanguageCode
  enabledLanguageCodes: LanguageCode[]
  schema: ColumnSchemaExtended[]
  primaryKey: string
  editData: Record<string, any>
  recordToEdit: CollectionData | null
  isDuplicate: boolean
  setEditData: React.Dispatch<React.SetStateAction<Record<string, any>>>
  setEditError: (error: string | null) => void
  setEditOpen: (open: boolean) => void
  setRecordToEdit: (record: CollectionData | null) => void
  setIsDuplicate: (isDuplicate: boolean) => void
  setPriceInputs: (updater: (prev: Record<string, string>) => Record<string, string>) => void
  setJsonFieldLanguage: (updater: (prev: Record<string, LanguageCode>) => Record<string, LanguageCode>) => void
  isAutoGeneratedField: (fieldName: string, hasRelation?: boolean) => boolean
  getI18nJsonFieldsForCollection: (collection: string) => string[]
  formData: Record<string, any>
  setFormData: React.Dispatch<React.SetStateAction<Record<string, any>>>
  setCreateError: (error: string | null) => void
  setCreateOpen: (open: boolean) => void
  createDataInEntries: DataInEntry[]
  editDataInEntries: DataInEntry[]
  entriesToLanguageObject: (entries: DataInEntry[]) => any
  editableFields: ColumnSchemaExtended[]
  fetchData: () => Promise<void>
}

export function useDataTableFormCallbacks({
  collection,
  locale,
  enabledLanguageCodes,
  schema,
  primaryKey,
  editData,
  recordToEdit,
  isDuplicate,
  setEditData,
  setEditError,
  setEditOpen,
  setRecordToEdit,
  setIsDuplicate,
  setPriceInputs,
  setJsonFieldLanguage,
  isAutoGeneratedField,
  getI18nJsonFieldsForCollection,
  formData,
  setFormData,
  setCreateError,
  setCreateOpen,
  createDataInEntries,
  editDataInEntries,
  entriesToLanguageObject,
  editableFields,
  fetchData,
}: FormCallbacksParams) {
  const handleFieldChange = React.useCallback(
    (fieldName: string, value: string | boolean | Date | number | null) => {
      setFormData((prev: Record<string, any>) => ({ ...prev, [fieldName]: value }))
    },
    [setFormData]
  )

  const handleEditFieldChange = React.useCallback(
    (fieldName: string, value: string | boolean | Date | number | null) => {
      const field = schema.find((f) => f.name === fieldName)
      if (field?.relation) {
        console.log(`[handleEditFieldChange] Relation field ${fieldName}:`, {
          value,
          type: typeof value,
          isObject: typeof value === "object" && value !== null,
        })
      }
      setEditData((prev) => ({ ...prev, [fieldName]: value }))
    },
    [schema, setEditData]
  )

  const onEditRequest = React.useCallback(
    (row: Row<CollectionData>) => {
      try {
        const record = row.original
        setRecordToEdit(record)
        const initial: Record<string, any> = {}
        const pricePrefill: Record<string, string> = {}
        const i18nFields = getI18nJsonFieldsForCollection(collection)

        if (collection === "roles") {
          initial.id = record.id ?? null
          initial.uuid = record.uuid ?? null
          initial.order = record.order ?? null
          initial.created_at = record.created_at ?? null
          initial.updated_at = record.updated_at ?? null
        }
        if (collection === "contractors") {
          initial.id = record.id ?? null
          initial.uuid = record.uuid ?? null
          initial.xaid = record.xaid ?? null
          initial.order = record.order ?? null
          initial.created_at = record.created_at ?? null
          initial.updated_at = record.updated_at ?? null
        }

        for (const col of schema) {
          if (!isAutoGeneratedField(col.name, !!col.relation) && !col.primary) {
            if (col.fieldType === "boolean") {
              initial[col.name] =
                record[col.name] === 1 || record[col.name] === true || record[col.name] === "1" || record[col.name] === "true"
            } else if (col.fieldType === "date" || col.fieldType === "time" || col.fieldType === "datetime") {
              initial[col.name] = record[col.name] ? new Date(record[col.name]) : null
            } else if (col.fieldType === "json" && i18nFields.includes(col.name)) {
              let jsonValue = record[col.name]

              if (col.name === "category" && (!jsonValue || jsonValue === "" || jsonValue === null)) {
                const dataIn = record.data_in
                if (dataIn && typeof dataIn === "string") {
                  try {
                    const dataInJson = JSON.parse(dataIn)
                    if (dataInJson && typeof dataInJson === "object" && dataInJson.category) {
                      jsonValue = dataInJson.category
                    }
                  } catch {
                    // ignore
                  }
                }
              }

              if (typeof jsonValue === "string") {
                try {
                  jsonValue = JSON.parse(jsonValue)
                } catch {
                  const replicated: Record<string, string> = {}
                  enabledLanguageCodes.forEach((lc) => {
                    replicated[lc] = jsonValue || ""
                  })
                  jsonValue = replicated
                }
              }
              if (!jsonValue || typeof jsonValue !== "object") {
                jsonValue = {}
              }
              enabledLanguageCodes.forEach((lc) => {
                initial[`${col.name}_${lc}`] = (jsonValue as any)[lc] || ""
              })
              setJsonFieldLanguage((prev) => ({ ...prev, [col.name]: locale }))
            } else if (col.fieldType === "price") {
              const cents = record[col.name]
              const numericCents = cents == null ? null : Number(cents)
              initial[col.name] = numericCents
              pricePrefill[`edit-${col.name}`] =
                numericCents == null || Number.isNaN(numericCents) ? "" : (numericCents / 100).toFixed(2)
            } else if (col.fieldType === "json") {
              if (record[col.name] != null) {
                if (typeof record[col.name] === "string") {
                  try {
                    initial[col.name] = JSON.parse(record[col.name])
                  } catch {
                    initial[col.name] = {}
                  }
                } else {
                  initial[col.name] = record[col.name]
                }
              } else {
                initial[col.name] = {}
              }
            } else {
              initial[col.name] = record[col.name] != null ? String(record[col.name]) : ""
            }
          }
        }
        setEditData(initial)
        if (Object.keys(pricePrefill).length > 0) {
          setPriceInputs((prev) => ({ ...prev, ...pricePrefill }))
        }
        setEditError(null)
        setEditOpen(true)
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e)
        setEditError(message)
        setEditOpen(true)
      }
    },
    [
      schema,
      isAutoGeneratedField,
      collection,
      locale,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      setRecordToEdit,
      setEditData,
      setPriceInputs,
      setJsonFieldLanguage,
      setEditError,
      setEditOpen,
    ]
  )

  const onDuplicateRequest = React.useCallback(
    (row: Row<CollectionData>) => {
      try {
        const record = row.original
        const duplicatedRecord = { ...record }
        delete duplicatedRecord.id
        delete duplicatedRecord.uuid
        delete duplicatedRecord.created_at
        delete duplicatedRecord.updated_at
        delete duplicatedRecord.deleted_at

        setRecordToEdit(duplicatedRecord)
        const initial: Record<string, any> = {}
        const pricePrefill: Record<string, string> = {}
        const i18nFields = getI18nJsonFieldsForCollection(collection)

        for (const col of schema) {
          if (!isAutoGeneratedField(col.name, !!col.relation) && !col.primary) {
            if (col.fieldType === "boolean") {
              initial[col.name] =
                duplicatedRecord[col.name] === 1 ||
                duplicatedRecord[col.name] === true ||
                duplicatedRecord[col.name] === "1" ||
                duplicatedRecord[col.name] === "true"
            } else if (col.fieldType === "date" || col.fieldType === "time" || col.fieldType === "datetime") {
              initial[col.name] = duplicatedRecord[col.name] ? new Date(duplicatedRecord[col.name]) : null
            } else if (col.fieldType === "json" && i18nFields.includes(col.name)) {
              let jsonValue = duplicatedRecord[col.name]

              if (col.name === "category" && (!jsonValue || jsonValue === "" || jsonValue === null)) {
                const dataIn = duplicatedRecord.data_in
                if (dataIn && typeof dataIn === "string") {
                  try {
                    const dataInJson = JSON.parse(dataIn)
                    if (dataInJson && typeof dataInJson === "object" && dataInJson.category) {
                      jsonValue = dataInJson.category
                    }
                  } catch {
                    // ignore
                  }
                }
              }

              if (typeof jsonValue === "string") {
                try {
                  jsonValue = JSON.parse(jsonValue)
                } catch {
                  const replicated: Record<string, string> = {}
                  enabledLanguageCodes.forEach((lc) => {
                    replicated[lc] = jsonValue || ""
                  })
                  jsonValue = replicated
                }
              }
              if (!jsonValue || typeof jsonValue !== "object") {
                jsonValue = {}
              }
              enabledLanguageCodes.forEach((lc) => {
                initial[`${col.name}_${lc}`] = (jsonValue as any)[lc] || ""
              })
              setJsonFieldLanguage((prev) => ({ ...prev, [col.name]: locale }))
            } else if (col.fieldType === "price") {
              const cents = duplicatedRecord[col.name]
              const numericCents = cents == null ? null : Number(cents)
              initial[col.name] = numericCents
              pricePrefill[`edit-${col.name}`] =
                numericCents == null || Number.isNaN(numericCents) ? "" : (numericCents / 100).toFixed(2)
            } else if (col.fieldType === "json") {
              if (duplicatedRecord[col.name] != null) {
                if (typeof duplicatedRecord[col.name] === "string") {
                  try {
                    initial[col.name] = JSON.parse(duplicatedRecord[col.name])
                  } catch {
                    initial[col.name] = {}
                  }
                } else {
                  initial[col.name] = duplicatedRecord[col.name]
                }
              } else {
                initial[col.name] = {}
              }
            } else if (col.relation) {
              const relationValue = duplicatedRecord[col.name]
              if (relationValue != null) {
                if (typeof relationValue === "object" && !Array.isArray(relationValue)) {
                  const idValue =
                    (relationValue as any)[col.relation.valueField] ||
                    (relationValue as any).id ||
                    (relationValue as any)[primaryKey]
                  initial[col.name] = idValue != null ? String(idValue) : ""
                } else {
                  initial[col.name] = String(relationValue)
                }
              } else {
                initial[col.name] = ""
              }
            } else {
              initial[col.name] = duplicatedRecord[col.name] != null ? String(duplicatedRecord[col.name]) : ""
            }
          }
        }
        setEditData(initial)
        if (Object.keys(pricePrefill).length > 0) {
          setPriceInputs((prev) => ({ ...prev, ...pricePrefill }))
        }
        setEditError(null)
        setIsDuplicate(true)
        setEditOpen(true)
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e)
        setEditError(message)
        setIsDuplicate(false)
        setEditOpen(true)
      }
    },
    [
      schema,
      isAutoGeneratedField,
      collection,
      locale,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      primaryKey,
      setRecordToEdit,
      setEditData,
      setPriceInputs,
      setJsonFieldLanguage,
      setEditError,
      setIsDuplicate,
      setEditOpen,
    ]
  )

  const handleCreateSubmit = React.useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault()
      setCreateError(null)
      try {
        const i18nFields = getI18nJsonFieldsForCollection(collection)
        const payload = Object.entries(formData).reduce((acc, [key, value]) => {
          const i18nMatch = key.match(/^(.+)_([a-z]{2})$/)
          if (i18nMatch) {
            const baseField = i18nMatch[1]
            const lang = i18nMatch[2] as LanguageCode
            if (i18nFields.includes(baseField) && enabledLanguageCodes.includes(lang)) {
              const existing = (acc[baseField] as Record<string, string>) || {}
              acc[baseField] = { ...existing, [lang]: (value as string) || "" }
              return acc
            }
          }

          if (i18nMatch && enabledLanguageCodes.includes(i18nMatch[2] as LanguageCode)) {
            const baseField = i18nMatch[1]
            if (getI18nJsonFieldsForCollection(collection).includes(baseField)) {
              return acc
            }
          }

          const field = schema.find((f) => f.name === key)

          if (field?.relation) {
            if (value === "" && field.nullable) {
              acc[key] = null
            } else if (value !== "" && value != null) {
              if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                console.warn(`[handleCreateSubmit] Relation field ${key} has object value, extracting ID:`, value)
                const idValue = (value as any)[field.relation.valueField] || (value as any).id || (value as any)[primaryKey]
                acc[key] = idValue != null ? idValue : null
              } else {
                console.log(`[handleCreateSubmit] Relation field ${key} value:`, value, typeof value)
                acc[key] = value
              }
            } else if (!field.nullable && value === "") {
              return acc
            } else {
              acc[key] = value
            }
          } else if (field?.fieldType === "json" && value != null && typeof value === "object" && !(value instanceof Date)) {
            acc[key] = value
          } else if (field?.fieldType === "price") {
            if (value != null && typeof value === "number") {
              acc[key] = value
            } else if (value === null && field.nullable) {
              acc[key] = null
            }
          } else if (value instanceof Date) {
            acc[key] = value.toISOString()
          } else {
            acc[key] = value
          }

          return acc
        }, {} as Record<string, any>)

        const processedDataIn = entriesToLanguageObjectValue(createDataInEntries, enabledLanguageCodes)
        payload.data_in = processedDataIn

        console.log("[handleCreateSubmit] Payload before sending:", JSON.stringify(payload, null, 2))

        const res = await fetch(`/api/admin/${encodeURIComponent(collection)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify(payload),
        })
        if (!res.ok) {
          const json = await res.json() as { error?: string }
          throw new Error(json.error || `Create failed: ${res.status}`)
        }
        setCreateOpen(false)
        setFormData({})
        setPriceInputs((prev) => {
          const newInputs = { ...prev }
          editableFields.forEach((field) => {
            if (field.fieldType === "price") {
              delete newInputs[`create-${field.name}`]
            }
          })
          return newInputs
        })
        await fetchData()
      } catch (e) {
        setCreateError((e as Error).message)
      }
    },
    [
      collection,
      formData,
      setFormData,
      setCreateError,
      setCreateOpen,
      createDataInEntries,
      schema,
      primaryKey,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      editableFields,
      setPriceInputs,
      fetchData,
    ]
  )

  const handleEditSubmit = React.useCallback(
    async (e: React.FormEvent) => {
      const currentEditData = editData
      const currentRecordToEdit = recordToEdit
      const currentIsDuplicate = isDuplicate
      e.preventDefault()
      if (!recordToEdit) return

      if (isDuplicate) {
        setEditError(null)
        try {
          const i18nFields = getI18nJsonFieldsForCollection(collection)
          const payload = Object.entries(editData).reduce((acc, [key, value]) => {
            const i18nMatch = key.match(/^(.+)_([a-z]{2})$/)
            if (i18nMatch) {
              const baseField = i18nMatch[1]
              const lang = i18nMatch[2] as LanguageCode
              if (i18nFields.includes(baseField) && enabledLanguageCodes.includes(lang)) {
                const existing = (acc[baseField] as Record<string, string>) || {}
                acc[baseField] = { ...existing, [lang]: (value as string) || "" }
                return acc
              }
            }

            if (i18nMatch && enabledLanguageCodes.includes(i18nMatch[2] as LanguageCode)) {
              const baseField = i18nMatch[1]
              if (getI18nJsonFieldsForCollection(collection).includes(baseField)) {
                return acc
              }
            }

            const field = schema.find((f) => f.name === key)

            if (field?.relation) {
              if (value === "" && field.nullable) {
                acc[key] = null
              } else if (value !== "" && value != null) {
                if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                  console.warn(`[handleCreateSubmit] Relation field ${key} has object value, extracting ID:`, value)
                  const idValue = (value as any)[field.relation.valueField] || (value as any).id || (value as any)[primaryKey]
                  acc[key] = idValue != null ? idValue : null
                } else {
                  console.log(`[handleCreateSubmit] Relation field ${key} value:`, value, typeof value)
                  acc[key] = value
                }
              } else if (!field.nullable && value === "") {
                return acc
              } else {
                acc[key] = value
              }
            } else if (field?.fieldType === "json" && value != null && typeof value === "object" && !(value instanceof Date)) {
              acc[key] = value
            } else if (field?.fieldType === "price") {
              if (value != null && typeof value === "number") {
                acc[key] = value
              } else if (value === null && field.nullable) {
                acc[key] = null
              }
            } else if (value instanceof Date) {
              acc[key] = value.toISOString()
            } else {
              acc[key] = value
            }

            return acc
          }, {} as Record<string, any>)

          const processedDataIn = entriesToLanguageObjectValue(editDataInEntries, enabledLanguageCodes)
          payload.data_in = processedDataIn

          console.log("[handleEditSubmit] Duplicate payload before sending:", JSON.stringify(payload, null, 2))

          const res = await fetch(`/api/admin/${encodeURIComponent(collection)}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify(payload),
          })
          if (!res.ok) {
            const json = await res.json() as { error?: string }
            throw new Error(json.error || `Create failed: ${res.status}`)
          }
          setEditOpen(false)
          setRecordToEdit(null)
          setEditData({})
          setIsDuplicate(false)
          setPriceInputs((prev) => {
            const newInputs = { ...prev }
            schema.filter((f) => !isAutoGeneratedField(f.name, !!f.relation) && !f.primary && !f.hidden).forEach((field) => {
              if (field.fieldType === "price") {
                delete newInputs[`edit-${field.name}`]
              }
            })
            return newInputs
          })
          await fetchData()
          return
        } catch (e) {
          setEditError((e as Error).message)
          return
        }
      }
      setEditError(null)
      try {
        const i18nFields = getI18nJsonFieldsForCollection(collection)
        const payload = Object.entries(editData).reduce((acc, [key, value]) => {
          const i18nMatch = key.match(/^(.+)_([a-z]{2})$/)
          if (i18nMatch) {
            const baseField = i18nMatch[1]
            const lang = i18nMatch[2] as LanguageCode
            if (i18nFields.includes(baseField) && enabledLanguageCodes.includes(lang)) {
              const existing = (acc[baseField] as Record<string, string>) || {}
              acc[baseField] = { ...existing, [lang]: (value as string) || "" }
              return acc
            }
          }

          if (i18nMatch && enabledLanguageCodes.includes(i18nMatch[2] as LanguageCode)) {
            const baseField = i18nMatch[1]
            if (getI18nJsonFieldsForCollection(collection).includes(baseField)) {
              return acc
            }
          }

          const field = schema.find((f) => f.name === key)

          if (field?.fieldType === "json" && value != null && typeof value === "object" && !(value instanceof Date)) {
            acc[key] = value
          } else if (field?.fieldType === "price") {
            if (value != null && typeof value === "number") {
              acc[key] = value
            } else if (value === null && field.nullable) {
              acc[key] = null
            }
          } else if (value instanceof Date) {
            acc[key] = value.toISOString()
          } else {
            acc[key] = value
          }

          return acc
        }, {} as Record<string, any>)

        const processedDataIn = entriesToLanguageObjectValue(editDataInEntries, enabledLanguageCodes)
        payload.data_in = processedDataIn

        console.log("[handleEditSubmit] Payload before sending:", JSON.stringify(payload, null, 2))

        const idValue = recordToEdit[primaryKey]
        const res = await fetch(`/api/admin/${encodeURIComponent(collection)}/${encodeURIComponent(String(idValue))}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify(payload),
        })
        if (!res.ok) {
          const json = await res.json() as { error?: string }
          throw new Error(json.error || `Update failed: ${res.status}`)
        }
        setEditOpen(false)
        setRecordToEdit(null)
        setEditData({})
        setIsDuplicate(false)
        setPriceInputs((prev) => {
          const newInputs = { ...prev }
          schema.filter((f) => !isAutoGeneratedField(f.name, !!f.relation) && !f.primary && !f.hidden).forEach((field) => {
            if (field.fieldType === "price") {
              delete newInputs[`edit-${field.name}`]
            }
          })
          return newInputs
        })
        await fetchData()
      } catch (e) {
        setEditError((e as Error).message)
      }
    },
    [
      collection,
      schema,
      primaryKey,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      editData,
      recordToEdit,
      isDuplicate,
      editDataInEntries,
      isAutoGeneratedField,
      setEditError,
      setEditOpen,
      setRecordToEdit,
      setEditData,
      setIsDuplicate,
      setPriceInputs,
      fetchData,
    ]
  )

  return {
    handleFieldChange,
    handleEditFieldChange,
    onEditRequest,
    onDuplicateRequest,
    handleCreateSubmit,
    handleEditSubmit,
  }
}
