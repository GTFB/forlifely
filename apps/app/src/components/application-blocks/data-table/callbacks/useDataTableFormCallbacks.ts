import * as React from "react"
import type { Row } from "@tanstack/react-table"
import type { CollectionData, ColumnSchemaExtended, DataInEntry } from "../types"
import type { LanguageCode } from "../state/useDataTableMetaState"
import { entriesToLanguageObject as entriesToLanguageObjectValue } from "../utils/dataInHelpers"

type FormCallbacksParams = {
  collection: string
  locale: LanguageCode
  enabledLanguageCodes: LanguageCode[]
  schema: ColumnSchemaExtended[]
  primaryKey: string
  editData: Record<string, any>
  recordToEdit: CollectionData | null
  isDuplicate: boolean
  setEditData: React.Dispatch<React.SetStateAction<Record<string, any>>>
  setEditError: (error: string | null) => void
  setEditOpen: (open: boolean) => void
  setRecordToEdit: (record: CollectionData | null) => void
  setIsDuplicate: (isDuplicate: boolean) => void
  setPriceInputs: (updater: (prev: Record<string, string>) => Record<string, string>) => void
  setJsonFieldLanguage: (updater: (prev: Record<string, LanguageCode>) => Record<string, LanguageCode>) => void
  isAutoGeneratedField: (fieldName: string, hasRelation?: boolean) => boolean
  getI18nJsonFieldsForCollection: (collection: string) => string[]
  formData: Record<string, any>
  setFormData: React.Dispatch<React.SetStateAction<Record<string, any>>>
  setCreateError: (error: string | null) => void
  setCreateOpen: (open: boolean) => void
  createDataInEntries: DataInEntry[]
  editDataInEntries: DataInEntry[]
  entriesToLanguageObject: (entries: DataInEntry[]) => any
  editableFields: ColumnSchemaExtended[]
  fetchData: () => Promise<void>
}

export function useDataTableFormCallbacks({
  collection,
  locale,
  enabledLanguageCodes,
  schema,
  primaryKey,
  editData,
  recordToEdit,
  isDuplicate,
  setEditData,
  setEditError,
  setEditOpen,
  setRecordToEdit,
  setIsDuplicate,
  setPriceInputs,
  setJsonFieldLanguage,
  isAutoGeneratedField,
  getI18nJsonFieldsForCollection,
  formData,
  setFormData,
  setCreateError,
  setCreateOpen,
  createDataInEntries,
  editDataInEntries,
  entriesToLanguageObject,
  editableFields,
  fetchData,
}: FormCallbacksParams) {
  const handleFieldChange = React.useCallback(
    (fieldName: string, value: string | boolean | Date | number | null) => {
      setFormData((prev: Record<string, any>) => ({ ...prev, [fieldName]: value }))
    },
    [setFormData]
  )

  const handleEditFieldChange = React.useCallback(
    (fieldName: string, value: string | boolean | Date | number | null) => {
      const field = schema.find((f) => f.name === fieldName)
      if (field?.relation) {
        console.log(`[handleEditFieldChange] Relation field ${fieldName}:`, {
          value,
          type: typeof value,
          isObject: typeof value === "object" && value !== null,
        })
      }
      setEditData((prev) => ({ ...prev, [fieldName]: value }))
    },
    [schema, setEditData]
  )

  const onEditRequest = React.useCallback(
    (row: Row<CollectionData>) => {
      try {
        const record = row.original
        setRecordToEdit(record)
        const initial: Record<string, any> = {}
        const pricePrefill: Record<string, string> = {}
        const i18nFields = getI18nJsonFieldsForCollection(collection)

        if (collection === "roles") {
          initial.id = record.id ?? null
          initial.uuid = record.uuid ?? null
          initial.order = record.order ?? null
          initial.created_at = record.created_at ?? null
          initial.updated_at = record.updated_at ?? null
        }
        if (collection === "contractors") {
          initial.id = record.id ?? null
          initial.uuid = record.uuid ?? null
          initial.xaid = record.xaid ?? null
          initial.order = record.order ?? null
          initial.created_at = record.created_at ?? null
          initial.updated_at = record.updated_at ?? null
        }

        for (const col of schema) {
          if (!isAutoGeneratedField(col.name, !!col.relation) && !col.primary) {
            // Skip password fields - they should be empty by default (user must explicitly enter new password)
            if (col.fieldType === "password" || (col as any).type === "password") {
              initial[col.name] = ""
              continue
            }
            
            if (col.fieldType === "boolean") {
              initial[col.name] =
                record[col.name] === 1 || record[col.name] === true || record[col.name] === "1" || record[col.name] === "true"
            } else if (col.fieldType === "date" || col.fieldType === "time" || col.fieldType === "datetime") {
              initial[col.name] = record[col.name] ? new Date(record[col.name]) : null
            } else if (col.fieldType === "json" && i18nFields.includes(col.name)) {
              let jsonValue = record[col.name]

              if (col.name === "category" && (!jsonValue || jsonValue === "" || jsonValue === null)) {
                const dataIn = record.data_in
                if (dataIn && typeof dataIn === "string") {
                  try {
                    const dataInJson = JSON.parse(dataIn)
                    if (dataInJson && typeof dataInJson === "object" && dataInJson.category) {
                      jsonValue = dataInJson.category
                    }
                  } catch {
                    // ignore
                  }
                }
              }

              if (typeof jsonValue === "string") {
                try {
                  jsonValue = JSON.parse(jsonValue)
                } catch {
                  const replicated: Record<string, string> = {}
                  enabledLanguageCodes.forEach((lc) => {
                    replicated[lc] = jsonValue || ""
                  })
                  jsonValue = replicated
                }
              }
              if (!jsonValue || typeof jsonValue !== "object") {
                jsonValue = {}
              }
              enabledLanguageCodes.forEach((lc) => {
                initial[`${col.name}_${lc}`] = (jsonValue as any)[lc] || ""
              })
              setJsonFieldLanguage((prev) => ({ ...prev, [col.name]: locale }))
            } else if (col.fieldType === "price") {
              const cents = record[col.name]
              const numericCents = cents == null ? null : Number(cents)
              initial[col.name] = numericCents
              pricePrefill[`edit-${col.name}`] =
                numericCents == null || Number.isNaN(numericCents) ? "" : (numericCents / 100).toFixed(2)
            } else if (col.fieldType === "json") {
              if (record[col.name] != null) {
                if (typeof record[col.name] === "string") {
                  try {
                    initial[col.name] = JSON.parse(record[col.name])
                  } catch {
                    initial[col.name] = {}
                  }
                } else {
                  initial[col.name] = record[col.name]
                }
              } else {
                initial[col.name] = {}
              }
            } else {
              initial[col.name] = record[col.name] != null ? String(record[col.name]) : ""
            }
          }
        }
        setEditData(initial)
        if (Object.keys(pricePrefill).length > 0) {
          setPriceInputs((prev) => ({ ...prev, ...pricePrefill }))
        }
        setEditError(null)
        setEditOpen(true)
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e)
        setEditError(message)
        setEditOpen(true)
      }
    },
    [
      schema,
      isAutoGeneratedField,
      collection,
      locale,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      setRecordToEdit,
      setEditData,
      setPriceInputs,
      setJsonFieldLanguage,
      setEditError,
      setEditOpen,
    ]
  )

  const onDuplicateRequest = React.useCallback(
    (row: Row<CollectionData>) => {
      try {
        const record = row.original
        const duplicatedRecord = { ...record }
        delete duplicatedRecord.id
        delete duplicatedRecord.uuid
        delete duplicatedRecord.created_at
        delete duplicatedRecord.updated_at
        delete duplicatedRecord.deleted_at

        setRecordToEdit(duplicatedRecord)
        const initial: Record<string, any> = {}
        const pricePrefill: Record<string, string> = {}
        const i18nFields = getI18nJsonFieldsForCollection(collection)

        for (const col of schema) {
          if (!isAutoGeneratedField(col.name, !!col.relation) && !col.primary) {
            if (col.fieldType === "boolean") {
              initial[col.name] =
                duplicatedRecord[col.name] === 1 ||
                duplicatedRecord[col.name] === true ||
                duplicatedRecord[col.name] === "1" ||
                duplicatedRecord[col.name] === "true"
            } else if (col.fieldType === "date" || col.fieldType === "time" || col.fieldType === "datetime") {
              initial[col.name] = duplicatedRecord[col.name] ? new Date(duplicatedRecord[col.name]) : null
            } else if (col.fieldType === "json" && i18nFields.includes(col.name)) {
              let jsonValue = duplicatedRecord[col.name]

              if (col.name === "category" && (!jsonValue || jsonValue === "" || jsonValue === null)) {
                const dataIn = duplicatedRecord.data_in
                if (dataIn && typeof dataIn === "string") {
                  try {
                    const dataInJson = JSON.parse(dataIn)
                    if (dataInJson && typeof dataInJson === "object" && dataInJson.category) {
                      jsonValue = dataInJson.category
                    }
                  } catch {
                    // ignore
                  }
                }
              }

              if (typeof jsonValue === "string") {
                try {
                  jsonValue = JSON.parse(jsonValue)
                } catch {
                  const replicated: Record<string, string> = {}
                  enabledLanguageCodes.forEach((lc) => {
                    replicated[lc] = jsonValue || ""
                  })
                  jsonValue = replicated
                }
              }
              if (!jsonValue || typeof jsonValue !== "object") {
                jsonValue = {}
              }
              enabledLanguageCodes.forEach((lc) => {
                initial[`${col.name}_${lc}`] = (jsonValue as any)[lc] || ""
              })
              setJsonFieldLanguage((prev) => ({ ...prev, [col.name]: locale }))
            } else if (col.fieldType === "price") {
              const cents = duplicatedRecord[col.name]
              const numericCents = cents == null ? null : Number(cents)
              initial[col.name] = numericCents
              pricePrefill[`edit-${col.name}`] =
                numericCents == null || Number.isNaN(numericCents) ? "" : (numericCents / 100).toFixed(2)
            } else if (col.fieldType === "json") {
              if (duplicatedRecord[col.name] != null) {
                if (typeof duplicatedRecord[col.name] === "string") {
                  try {
                    initial[col.name] = JSON.parse(duplicatedRecord[col.name])
                  } catch {
                    initial[col.name] = {}
                  }
                } else {
                  initial[col.name] = duplicatedRecord[col.name]
                }
              } else {
                initial[col.name] = {}
              }
            } else if (col.relation) {
              const relationValue = duplicatedRecord[col.name]
              if (relationValue != null) {
                if (typeof relationValue === "object" && !Array.isArray(relationValue)) {
                  const idValue =
                    (relationValue as any)[col.relation.valueField] ||
                    (relationValue as any).id ||
                    (relationValue as any)[primaryKey]
                  initial[col.name] = idValue != null ? String(idValue) : ""
                } else {
                  initial[col.name] = String(relationValue)
                }
              } else {
                initial[col.name] = ""
              }
            } else {
              initial[col.name] = duplicatedRecord[col.name] != null ? String(duplicatedRecord[col.name]) : ""
            }
          }
        }
        setEditData(initial)
        if (Object.keys(pricePrefill).length > 0) {
          setPriceInputs((prev) => ({ ...prev, ...pricePrefill }))
        }
        setEditError(null)
        setIsDuplicate(true)
        setEditOpen(true)
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e)
        setEditError(message)
        setIsDuplicate(false)
        setEditOpen(true)
      }
    },
    [
      schema,
      isAutoGeneratedField,
      collection,
      locale,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      primaryKey,
      setRecordToEdit,
      setEditData,
      setPriceInputs,
      setJsonFieldLanguage,
      setEditError,
      setIsDuplicate,
      setEditOpen,
    ]
  )

  const handleCreateSubmit = React.useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault()
      setCreateError(null)
      try {
        const i18nFields = getI18nJsonFieldsForCollection(collection)
        const dataInFields: Record<string, any> = {}
        const payload = Object.entries(formData).reduce((acc, [key, value]) => {
          // Handle virtual fields with data_in. prefix
          if (key.startsWith('data_in.')) {
            const dataInKey = key.replace('data_in.', '')
            const field = schema.find((f) => f.name === key)
            
            // Process value based on field type
            if (field?.fieldType === "number") {
              dataInFields[dataInKey] = value != null && value !== "" ? Number(value) : (field.nullable ? null : 0)
            } else if (field?.fieldType === "price") {
              if (value != null && typeof value === "number") {
                dataInFields[dataInKey] = value
              } else if (value === null && field.nullable) {
                dataInFields[dataInKey] = null
              }
            } else if (value instanceof Date) {
              dataInFields[dataInKey] = value.toISOString()
            } else if (value !== "" && value != null) {
              dataInFields[dataInKey] = value
            } else if (field?.nullable) {
              dataInFields[dataInKey] = null
            }
            return acc // Skip adding to main payload
          }

          const i18nMatch = key.match(/^(.+)_([a-z]{2})$/)
          if (i18nMatch) {
            const baseField = i18nMatch[1]
            const lang = i18nMatch[2] as LanguageCode
            if (i18nFields.includes(baseField) && enabledLanguageCodes.includes(lang)) {
              const existing = (acc[baseField] as Record<string, string>) || {}
              acc[baseField] = { ...existing, [lang]: (value as string) || "" }
              return acc
            }
          }

          if (i18nMatch && enabledLanguageCodes.includes(i18nMatch[2] as LanguageCode)) {
            const baseField = i18nMatch[1]
            if (getI18nJsonFieldsForCollection(collection).includes(baseField)) {
              return acc
            }
          }

          const field = schema.find((f) => f.name === key)

          if (field?.relation) {
            if (value === "" && field.nullable) {
              acc[key] = null
            } else if (value !== "" && value != null) {
              if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                console.warn(`[handleCreateSubmit] Relation field ${key} has object value, extracting ID:`, value)
                const idValue = (value as any)[field.relation.valueField] || (value as any).id || (value as any)[primaryKey]
                acc[key] = idValue != null ? idValue : null
              } else {
                console.log(`[handleCreateSubmit] Relation field ${key} value:`, value, typeof value)
                acc[key] = value
              }
            } else if (!field.nullable && value === "") {
              return acc
            } else {
              acc[key] = value
            }
          } else if (field?.fieldType === "json" && value != null && typeof value === "object" && !(value instanceof Date)) {
            acc[key] = value
          } else if (field?.fieldType === "price") {
            if (value != null && typeof value === "number") {
              acc[key] = value
            } else if (value === null && field.nullable) {
              acc[key] = null
            }
          } else if (value instanceof Date) {
            acc[key] = value.toISOString()
          } else {
            acc[key] = value
          }

          return acc
        }, {} as Record<string, any>)

        // Filter out virtual fields from createDataInEntries (they are handled separately via dataInFields)
        // First, get all virtual field keys from schema (fields with data_in. prefix)
        const virtualFieldKeysFromSchema = new Set(
          schema
            .filter(f => f.name.startsWith('data_in.') && f.virtual)
            .map(f => f.name.replace('data_in.', ''))
        )
        
        // Also include keys from dataInFields (fields that were filled in formData with data_in. prefix)
        const virtualFieldKeys = new Set([
          ...Array.from(virtualFieldKeysFromSchema),
          ...Object.keys(dataInFields)
        ])
        
        console.log("[handleCreateSubmit] Virtual field keys:", Array.from(virtualFieldKeys))
        console.log("[handleCreateSubmit] createDataInEntries before filter:", createDataInEntries.map(e => e.key))
        
        const filteredDataInEntries = createDataInEntries.filter(entry => {
          const baseKey = entry.key.replace(/_[a-z]{2}$/i, '')
          // Exclude if it's a virtual field (either from schema or from formData)
          const shouldExclude = virtualFieldKeys.has(baseKey) || virtualFieldKeys.has(entry.key)
          if (shouldExclude) {
            console.log(`[handleCreateSubmit] Filtering out virtual field entry: ${entry.key} (baseKey: ${baseKey})`)
          }
          return !shouldExclude
        })
        
        console.log("[handleCreateSubmit] filteredDataInEntries after filter:", filteredDataInEntries.map(e => e.key))
        console.log("[handleCreateSubmit] dataInFields:", dataInFields)
        
        // Merge data_in fields from virtual fields and entries
        const processedDataIn = entriesToLanguageObjectValue(filteredDataInEntries, enabledLanguageCodes)
        payload.data_in = { ...processedDataIn, ...dataInFields }

        console.log("[handleCreateSubmit] Payload before sending:", JSON.stringify(payload, null, 2))

        const res = await fetch(`/api/admin/${encodeURIComponent(collection)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify(payload),
        })
        if (!res.ok) {
          let errorMessage = `Create failed: ${res.status}`
          let errorDetails: any = null
          try {
            const errorText = await res.text()
            console.error(`[handleCreateSubmit] API error response (status ${res.status}):`, errorText || '(empty response)')
            console.error(`[handleCreateSubmit] Response headers:`, Object.fromEntries(res.headers.entries()))
            
            if (errorText) {
              try {
                const json = JSON.parse(errorText) as { error?: string; message?: string; details?: string; sql?: string; values?: string[] }
                errorDetails = json
                errorMessage = json.message || json.details || json.error || errorText || errorMessage
                console.error(`[handleCreateSubmit] Parsed error JSON:`, json)
              } catch {
                errorMessage = errorText || errorMessage
              }
            } else {
              console.error(`[handleCreateSubmit] Empty error response body`)
            }
          } catch (e) {
            console.error(`[handleCreateSubmit] Failed to read error response:`, e)
          }
          
          const finalError = new Error(errorMessage)
          ;(finalError as any).status = res.status
          ;(finalError as any).details = errorDetails
          throw finalError
        }
        setCreateOpen(false)
        setFormData({})
        setPriceInputs((prev) => {
          const newInputs = { ...prev }
          editableFields.forEach((field) => {
            if (field.fieldType === "price") {
              delete newInputs[`create-${field.name}`]
            }
          })
          return newInputs
        })
        await fetchData()
      } catch (e) {
        setCreateError((e as Error).message)
      }
    },
    [
      collection,
      formData,
      setFormData,
      setCreateError,
      setCreateOpen,
      createDataInEntries,
      schema,
      primaryKey,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      editableFields,
      setPriceInputs,
      fetchData,
    ]
  )

  const handleEditSubmit = React.useCallback(
    async (e: React.FormEvent) => {
      const currentEditData = editData
      const currentRecordToEdit = recordToEdit
      const currentIsDuplicate = isDuplicate
      e.preventDefault()
      if (!recordToEdit) return

      if (isDuplicate) {
        setEditError(null)
        try {
          const i18nFields = getI18nJsonFieldsForCollection(collection)
          const dataInFields: Record<string, any> = {}
          const payload = Object.entries(editData).reduce((acc, [key, value]) => {
            // Handle virtual fields with data_in. prefix
            if (key.startsWith('data_in.')) {
              const dataInKey = key.replace('data_in.', '')
              const field = schema.find((f) => f.name === key)
              
              // Process value based on field type
              if (field?.fieldType === "number") {
                dataInFields[dataInKey] = value != null && value !== "" ? Number(value) : (field.nullable ? null : 0)
              } else if (field?.fieldType === "price") {
                if (value != null && typeof value === "number") {
                  dataInFields[dataInKey] = value
                } else if (value === null && field.nullable) {
                  dataInFields[dataInKey] = null
                }
              } else if (value instanceof Date) {
                dataInFields[dataInKey] = value.toISOString()
              } else if (value !== "" && value != null) {
                dataInFields[dataInKey] = value
              } else if (field?.nullable) {
                dataInFields[dataInKey] = null
              }
              return acc // Skip adding to main payload
            }

            const i18nMatch = key.match(/^(.+)_([a-z]{2})$/)
            if (i18nMatch) {
              const baseField = i18nMatch[1]
              const lang = i18nMatch[2] as LanguageCode
              if (i18nFields.includes(baseField) && enabledLanguageCodes.includes(lang)) {
                const existing = (acc[baseField] as Record<string, string>) || {}
                acc[baseField] = { ...existing, [lang]: (value as string) || "" }
                return acc
              }
            }

            if (i18nMatch && enabledLanguageCodes.includes(i18nMatch[2] as LanguageCode)) {
              const baseField = i18nMatch[1]
              if (getI18nJsonFieldsForCollection(collection).includes(baseField)) {
                return acc
              }
            }

            const field = schema.find((f) => f.name === key)

            if (field?.relation) {
              if (value === "" && field.nullable) {
                acc[key] = null
              } else if (value !== "" && value != null) {
                if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                  console.warn(`[handleCreateSubmit] Relation field ${key} has object value, extracting ID:`, value)
                  const idValue = (value as any)[field.relation.valueField] || (value as any).id || (value as any)[primaryKey]
                  acc[key] = idValue != null ? idValue : null
                } else {
                  console.log(`[handleCreateSubmit] Relation field ${key} value:`, value, typeof value)
                  acc[key] = value
                }
              } else if (!field.nullable && value === "") {
                return acc
              } else {
                acc[key] = value
              }
            } else if (field?.fieldType === "json" && value != null && typeof value === "object" && !(value instanceof Date)) {
              acc[key] = value
            } else if (field?.fieldType === "price") {
              if (value != null && typeof value === "number") {
                acc[key] = value
              } else if (value === null && field.nullable) {
                acc[key] = null
              }
            } else if (value instanceof Date) {
              acc[key] = value.toISOString()
            } else {
              acc[key] = value
            }

            return acc
          }, {} as Record<string, any>)

          // Filter out virtual fields from editDataInEntries (they are handled separately via dataInFields)
          // First, get all virtual field keys from schema (fields with data_in. prefix)
          const virtualFieldKeysFromSchema = new Set(
            schema
              .filter(f => f.name.startsWith('data_in.') && f.virtual)
              .map(f => f.name.replace('data_in.', ''))
          )
          
          // Also include keys from dataInFields (fields that were filled in editData with data_in. prefix)
          const virtualFieldKeys = new Set([
            ...Array.from(virtualFieldKeysFromSchema),
            ...Object.keys(dataInFields)
          ])
          
          const filteredDataInEntries = editDataInEntries.filter(entry => {
            const baseKey = entry.key.replace(/_[a-z]{2}$/i, '')
            // Exclude if it's a virtual field (either from schema or from editData)
            return !virtualFieldKeys.has(baseKey) && !virtualFieldKeys.has(entry.key)
          })
          
          // Merge data_in fields from virtual fields and entries
          const processedDataIn = entriesToLanguageObjectValue(filteredDataInEntries, enabledLanguageCodes)
          payload.data_in = { ...processedDataIn, ...dataInFields }

          console.log("[handleEditSubmit] Duplicate payload before sending:", JSON.stringify(payload, null, 2))

          const res = await fetch(`/api/admin/${encodeURIComponent(collection)}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify(payload),
          })
          if (!res.ok) {
            const json = await res.json() as { error?: string }
            throw new Error(json.error || `Create failed: ${res.status}`)
          }
          setEditOpen(false)
          setRecordToEdit(null)
          setEditData({})
          setIsDuplicate(false)
          setPriceInputs((prev) => {
            const newInputs = { ...prev }
            schema.filter((f) => !isAutoGeneratedField(f.name, !!f.relation) && !f.primary && !f.hidden).forEach((field) => {
              if (field.fieldType === "price") {
                delete newInputs[`edit-${field.name}`]
              }
            })
            return newInputs
          })
          await fetchData()
          return
        } catch (e) {
          setEditError((e as Error).message)
          return
        }
      }
      setEditError(null)
      try {
        const i18nFields = getI18nJsonFieldsForCollection(collection)
        
        // Find all password fields in schema to exclude them if unchanged
        // Check both fieldType and also get collection config to be sure
        const { getCollection } = await import('@/shared/collections/getCollection')
        const collectionConfig = getCollection(collection)
        const passwordFields = schema.filter(f => {
          const isPasswordByFieldType = f.fieldType === 'password' || (f as any).type === 'password'
          // Also check collection config directly
          const fieldColumn = (collectionConfig as any)[f.name] as any
          const isPasswordByConfig = fieldColumn?.options?.type === 'password' || fieldColumn?.options?.fieldType === 'password'
          // For users collection, also check password_hash by name
          const isPasswordByName = collection === 'users' && f.name === 'password_hash'
          return isPasswordByFieldType || isPasswordByConfig || isPasswordByName
        })
        
        // Log password fields for debugging
        if (passwordFields.length > 0) {
          console.log('[handleEditSubmit] Password fields found:', passwordFields.map(f => ({
            name: f.name,
            fieldType: f.fieldType,
            type: (f as any).type
          })))
        } else {
          console.log('[handleEditSubmit] No password fields found in schema. Collection:', collection)
        }
        
        const dataInFields: Record<string, any> = {}
        const payload = Object.entries(editData).reduce((acc, [key, value]) => {
          // Handle virtual fields with data_in. prefix
          if (key.startsWith('data_in.')) {
            const dataInKey = key.replace('data_in.', '')
            const field = schema.find((f) => f.name === key)
            
            // Process value based on field type
            if (field?.fieldType === "number") {
              dataInFields[dataInKey] = value != null && value !== "" ? Number(value) : (field.nullable ? null : 0)
            } else if (field?.fieldType === "price") {
              if (value != null && typeof value === "number") {
                dataInFields[dataInKey] = value
              } else if (value === null && field.nullable) {
                dataInFields[dataInKey] = null
              }
            } else if (value instanceof Date) {
              dataInFields[dataInKey] = value.toISOString()
            } else if (value !== "" && value != null) {
              dataInFields[dataInKey] = value
            } else if (field?.nullable) {
              dataInFields[dataInKey] = null
            }
            return acc // Skip adding to main payload
          }

          // Skip password fields that haven't changed
          const passwordField = passwordFields.find(f => f.name === key)
          if (passwordField) {
            const originalValue = recordToEdit[key]
            const editValue = value
            
            console.log(`[handleEditSubmit] Password field ${key}:`, {
              originalValue: originalValue ? `${String(originalValue).substring(0, 20)}...` : null,
              editValue: editValue ? `${String(editValue).substring(0, 20)}...` : null,
              isEmpty: editValue == null || editValue === '',
              isUnchanged: originalValue != null && editValue != null && String(editValue) === String(originalValue)
            })
            
            // Always exclude password fields if they are empty, null, or undefined
            if (editValue == null || editValue === '') {
              console.log(`[handleEditSubmit] Skipping empty password field: ${key}`)
              return acc // Skip empty password fields
            }
            
            // If password field matches original value, skip it (user didn't change password)
            if (originalValue != null && String(editValue) === String(originalValue)) {
              console.log(`[handleEditSubmit] Skipping unchanged password field: ${key}`)
              return acc // Skip unchanged password fields
            }
            
            // If both are null/undefined, skip it
            if (originalValue == null && editValue == null) {
              console.log(`[handleEditSubmit] Skipping null password field: ${key}`)
              return acc
            }
            
            // If we reach here, password was changed - include it
            console.log(`[handleEditSubmit] Including changed password field: ${key}`)
          }
          
          // Skip password confirmation fields if corresponding password field is unchanged
          const confirmFieldMatch = key.match(/^(.+)_confirm$/)
          if (confirmFieldMatch) {
            const passwordFieldName = confirmFieldMatch[1]
            const passwordField = passwordFields.find(f => f.name === passwordFieldName)
            if (passwordField) {
              const originalValue = recordToEdit[passwordFieldName]
              const editValue = editData[passwordFieldName]
              
              const isUnchanged = editValue == null || 
                                 editValue === '' || 
                                 (originalValue != null && String(editValue) === String(originalValue)) ||
                                 (originalValue == null && editValue == null)
              
              if (isUnchanged) {
                return acc // Skip confirmation field
              }
            }
          }
          
          const i18nMatch = key.match(/^(.+)_([a-z]{2})$/)
          if (i18nMatch) {
            const baseField = i18nMatch[1]
            const lang = i18nMatch[2] as LanguageCode
            if (i18nFields.includes(baseField) && enabledLanguageCodes.includes(lang)) {
              const existing = (acc[baseField] as Record<string, string>) || {}
              acc[baseField] = { ...existing, [lang]: (value as string) || "" }
              return acc
            }
          }

          if (i18nMatch && enabledLanguageCodes.includes(i18nMatch[2] as LanguageCode)) {
            const baseField = i18nMatch[1]
            if (getI18nJsonFieldsForCollection(collection).includes(baseField)) {
              return acc
            }
          }

          const field = schema.find((f) => f.name === key)

          if (field?.fieldType === "json" && value != null && typeof value === "object" && !(value instanceof Date)) {
            acc[key] = value
          } else if (field?.fieldType === "price") {
            if (value != null && typeof value === "number") {
              acc[key] = value
            } else if (value === null && field.nullable) {
              acc[key] = null
            }
          } else if (value instanceof Date) {
            acc[key] = value.toISOString()
          } else {
            acc[key] = value
          }

          return acc
        }, {} as Record<string, any>)

        // Filter out virtual fields from editDataInEntries (they are handled separately via dataInFields)
        // First, get all virtual field keys from schema (fields with data_in. prefix)
        const virtualFieldKeysFromSchema = new Set(
          schema
            .filter(f => f.name.startsWith('data_in.') && f.virtual)
            .map(f => f.name.replace('data_in.', ''))
        )
        
        // Also include keys from dataInFields (fields that were filled in editData with data_in. prefix)
        const virtualFieldKeys = new Set([
          ...Array.from(virtualFieldKeysFromSchema),
          ...Object.keys(dataInFields)
        ])
        
        const filteredEditDataInEntries = editDataInEntries.filter(entry => {
          const baseKey = entry.key.replace(/_[a-z]{2}$/i, '')
          // Exclude if it's a virtual field (either from schema or from editData)
          return !virtualFieldKeys.has(baseKey) && !virtualFieldKeys.has(entry.key)
        })
        
        // Merge data_in fields from virtual fields and entries
        const processedDataIn = entriesToLanguageObjectValue(filteredEditDataInEntries, enabledLanguageCodes)
        // Merge with existing data_in from record if it exists
        const existingDataIn = currentRecordToEdit?.data_in 
          ? (typeof currentRecordToEdit.data_in === 'string' 
              ? JSON.parse(currentRecordToEdit.data_in) 
              : currentRecordToEdit.data_in)
          : {}
        payload.data_in = { ...existingDataIn, ...processedDataIn, ...dataInFields }

        // Final check: ALWAYS remove password fields if they are empty or unchanged
        // This is a safety net to ensure password fields never cause validation errors
        for (const passwordField of passwordFields) {
          const fieldName = passwordField.name
          const confirmFieldName = `${fieldName}_confirm`
          
          // Always remove password fields if they exist in payload
          if (payload[fieldName] !== undefined) {
            const originalValue = recordToEdit[fieldName]
            const payloadValue = payload[fieldName]
            
            console.log(`[handleEditSubmit] Final check for password field ${fieldName}:`, {
              hasPayloadValue: payloadValue !== undefined,
              payloadValue: payloadValue ? `${String(payloadValue).substring(0, 20)}...` : null,
              originalValue: originalValue ? `${String(originalValue).substring(0, 20)}...` : null,
              isEmpty: payloadValue == null || payloadValue === '',
              isUnchanged: originalValue != null && payloadValue != null && String(payloadValue) === String(originalValue)
            })
            
            // ALWAYS remove if empty, null, undefined, or unchanged
            // Only keep if user explicitly entered a NEW password (not empty and different from original)
            const shouldRemove = payloadValue == null || 
                                payloadValue === '' || 
                                (originalValue != null && String(payloadValue) === String(originalValue)) ||
                                (originalValue == null && (payloadValue == null || payloadValue === ''))
            
            if (shouldRemove) {
              console.log(`[handleEditSubmit] REMOVING password field from payload: ${fieldName}`)
              delete payload[fieldName]
              delete payload[confirmFieldName]
            } else {
              console.log(`[handleEditSubmit] KEEPING password field in payload (user changed it): ${fieldName}`)
            }
          } else {
            // Also remove confirmation field if password field is not in payload
            if (payload[confirmFieldName] !== undefined) {
              console.log(`[handleEditSubmit] Removing orphaned password confirmation field: ${confirmFieldName}`)
              delete payload[confirmFieldName]
            }
          }
        }
        
        // HARD FIX: For users collection, always remove password_hash if it's empty or unchanged
        // This is a safety measure to prevent password validation errors when only roles are changed
        if (collection === 'users') {
          if (payload.password_hash !== undefined) {
            const originalPasswordHash = recordToEdit.password_hash
            const payloadPasswordHash = payload.password_hash
            
            // If password_hash is empty, null, undefined, or matches original, remove it
            if (payloadPasswordHash == null || 
                payloadPasswordHash === '' || 
                (originalPasswordHash != null && String(payloadPasswordHash) === String(originalPasswordHash))) {
              console.log('[handleEditSubmit] HARD FIX: Removing password_hash from payload for users collection')
              delete payload.password_hash
              delete payload.password_hash_confirm
            }
          }
          // Also ensure password_hash_confirm is removed if password_hash is not in payload
          if (payload.password_hash === undefined && payload.password_hash_confirm !== undefined) {
            console.log('[handleEditSubmit] HARD FIX: Removing orphaned password_hash_confirm')
            delete payload.password_hash_confirm
          }
        }
        
        console.log('[handleEditSubmit] Final payload keys:', Object.keys(payload))
        const remainingPasswordFields = passwordFields.filter(f => payload[f.name] !== undefined).map(f => f.name)
        if (remainingPasswordFields.length > 0) {
          console.warn('[handleEditSubmit] WARNING: Password fields still in payload:', remainingPasswordFields)
        } else {
          console.log('[handleEditSubmit] All password fields successfully removed from payload')
        }
        
        // Final safety check: if password_hash is still in payload, log it and remove it if empty
        if (payload.password_hash !== undefined && (payload.password_hash == null || payload.password_hash === '')) {
          console.error('[handleEditSubmit] ERROR: password_hash is still in payload but is empty! Removing it.')
          delete payload.password_hash
          delete payload.password_hash_confirm
        }

        console.log("[handleEditSubmit] Payload before sending:", JSON.stringify(payload, null, 2))

        const idValue = recordToEdit[primaryKey]
        const res = await fetch(`/api/admin/${encodeURIComponent(collection)}/${encodeURIComponent(String(idValue))}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify(payload),
        })
        if (!res.ok) {
          const json = await res.json() as { error?: string }
          throw new Error(json.error || `Update failed: ${res.status}`)
        }
        setEditOpen(false)
        setRecordToEdit(null)
        setEditData({})
        setIsDuplicate(false)
        setPriceInputs((prev) => {
          const newInputs = { ...prev }
          schema.filter((f) => !isAutoGeneratedField(f.name, !!f.relation) && !f.primary && !f.hidden).forEach((field) => {
            if (field.fieldType === "price") {
              delete newInputs[`edit-${field.name}`]
            }
          })
          return newInputs
        })
        await fetchData()
      } catch (e) {
        setEditError((e as Error).message)
      }
    },
    [
      collection,
      schema,
      primaryKey,
      enabledLanguageCodes,
      getI18nJsonFieldsForCollection,
      editData,
      recordToEdit,
      isDuplicate,
      editDataInEntries,
      isAutoGeneratedField,
      setEditError,
      setEditOpen,
      setRecordToEdit,
      setEditData,
      setIsDuplicate,
      setPriceInputs,
      fetchData,
    ]
  )

  return {
    handleFieldChange,
    handleEditFieldChange,
    onEditRequest,
    onDuplicateRequest,
    handleCreateSubmit,
    handleEditSubmit,
  }
}
