import * as React from "react"
import {
  IconCopy,
  IconPlus,
  IconX,
} from "@tabler/icons-react"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Input } from "@/packages/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs"
import { Textarea } from "@/components/ui/textarea"
import {
  ResponsiveDialog,
  ResponsiveDialogClose,
  ResponsiveDialogContent,
  ResponsiveDialogDescription,
  ResponsiveDialogFooter,
  ResponsiveDialogHeader,
  ResponsiveDialogTitle,
} from "@/packages/components/ui/revola"
import { DateTimePicker } from "@/packages/components/ui/date-time-picker"
import { PhoneInput } from "@/packages/components/ui/phone-input"
import { LANGUAGES } from "@/settings"
import { ComboboxSelect } from "./ComboboxSelect"
import { RelationSelect } from "./RelationSelect"
import { formatDateTimeForLocale } from "./functions/formatDateTimeForLocale"
import { copyToClipboard } from "./functions/copyToClipboard"
import type { ColumnSchemaExtended, CollectionData, DataInEntry } from "./types"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command"
import { Badge } from "@/components/ui/badge"
import { ChevronsUpDown, Check } from "lucide-react"
import { cn } from "@/lib/utils"

type LanguageCode = (typeof LANGUAGES)[number]["code"]

type DataTableFormDialogProps = {
  t: any
  collectionLabel: string
  collection: string
  search: string
  locale: LanguageCode
  translations: any
  enabledLanguageCodes: string[]
  supportedLanguageCodes: string[]
  editableFields: ColumnSchemaExtended[]
  schema: ColumnSchemaExtended[]
  isAutoGeneratedField: (name: string, isRelation: boolean) => boolean
  getI18nJsonFieldsForCollection: (collection: string) => string[]
  formData: Record<string, any>
  setFormData: React.Dispatch<React.SetStateAction<Record<string, any>>>
  handleFieldChange: (fieldName: string, value: string | boolean | Date | number | null) => void
  createOpen: boolean
  setCreateOpen: React.Dispatch<React.SetStateAction<boolean>>
  createError: string | null
  setCreateError: React.Dispatch<React.SetStateAction<string | null>>
  createFormTab: "main" | "info" | "details"
  setCreateFormTab: React.Dispatch<React.SetStateAction<"main" | "info" | "details">>
  createDataInLanguage: LanguageCode
  setCreateDataInLanguage: React.Dispatch<React.SetStateAction<LanguageCode>>
  createDataInEntries: DataInEntry[]
  setCreateDataInEntries: React.Dispatch<React.SetStateAction<DataInEntry[]>>
  createDataInRaw: string
  setCreateDataInRaw: React.Dispatch<React.SetStateAction<string>>
  createDataInRawError: string | null
  setCreateDataInRawError: React.Dispatch<React.SetStateAction<string | null>>
  createKeyInputs: Record<string, string>
  setCreateKeyInputs: React.Dispatch<React.SetStateAction<Record<string, string>>>
  createTitleInputs: Record<string, string>
  setCreateTitleInputs: React.Dispatch<React.SetStateAction<Record<string, string>>>
  createValueInputs: Record<string, string>
  setCreateValueInputs: React.Dispatch<React.SetStateAction<Record<string, string>>>
  handleCreateSubmit: (e: React.FormEvent) => Promise<void>
  editOpen: boolean
  setEditOpen: React.Dispatch<React.SetStateAction<boolean>>
  editData: Record<string, any>
  setEditData: React.Dispatch<React.SetStateAction<Record<string, any>>>
  editError: string | null
  setEditError: React.Dispatch<React.SetStateAction<string | null>>
  recordToEdit: CollectionData | null
  setRecordToEdit: React.Dispatch<React.SetStateAction<CollectionData | null>>
  isDuplicate: boolean
  setIsDuplicate: React.Dispatch<React.SetStateAction<boolean>>
  editFormTab: "main" | "info" | "details"
  setEditFormTab: React.Dispatch<React.SetStateAction<"main" | "info" | "details">>
  editDataInLanguage: LanguageCode
  setEditDataInLanguage: React.Dispatch<React.SetStateAction<LanguageCode>>
  editDataInEntries: DataInEntry[]
  setEditDataInEntries: React.Dispatch<React.SetStateAction<DataInEntry[]>>
  editDataInRaw: string
  setEditDataInRaw: React.Dispatch<React.SetStateAction<string>>
  editDataInRawError: string | null
  setEditDataInRawError: React.Dispatch<React.SetStateAction<string | null>>
  editKeyInputs: Record<string, string>
  setEditKeyInputs: React.Dispatch<React.SetStateAction<Record<string, string>>>
  editTitleInputs: Record<string, string>
  setEditTitleInputs: React.Dispatch<React.SetStateAction<Record<string, string>>>
  editValueInputs: Record<string, string>
  setEditValueInputs: React.Dispatch<React.SetStateAction<Record<string, string>>>
  handleEditFieldChange: (fieldName: string, value: string | boolean | Date | number | null) => void
  handleEditSubmit: (e: React.FormEvent) => Promise<void>
  jsonFieldLanguage: Record<string, LanguageCode>
  setJsonFieldLanguage: React.Dispatch<React.SetStateAction<Record<string, LanguageCode>>>
  priceInputs: Record<string, string>
  setPriceInputs: React.Dispatch<React.SetStateAction<Record<string, string>>>
  objectToEntries: (obj: any) => DataInEntry[]
  getUniqueBaseKeys: (entries: DataInEntry[]) => string[]
  getTitleAndValueForLanguage: (entries: DataInEntry[], baseKey: string, lang: LanguageCode) => { title: string; value: string }
  updateTitleAndValueForLanguage: (
    entries: DataInEntry[],
    baseKey: string,
    lang: LanguageCode,
    title: string,
    value: string,
    duplicateToAll?: boolean
  ) => DataInEntry[]
}

export function DataTableFormDialog({
  t,
  collectionLabel,
  collection,
  search,
  locale,
  translations,
  enabledLanguageCodes,
  supportedLanguageCodes,
  editableFields,
  schema,
  isAutoGeneratedField,
  getI18nJsonFieldsForCollection,
  formData,
  setFormData,
  handleFieldChange,
  createOpen,
  setCreateOpen,
  createError,
  setCreateError,
  createFormTab,
  setCreateFormTab,
  createDataInLanguage,
  setCreateDataInLanguage,
  createDataInEntries,
  setCreateDataInEntries,
  createDataInRaw,
  setCreateDataInRaw,
  createDataInRawError,
  setCreateDataInRawError,
  createKeyInputs,
  setCreateKeyInputs,
  createTitleInputs,
  setCreateTitleInputs,
  createValueInputs,
  setCreateValueInputs,
  handleCreateSubmit,
  editOpen,
  setEditOpen,
  editData,
  setEditData,
  editError,
  setEditError,
  recordToEdit,
  setRecordToEdit,
  isDuplicate,
  setIsDuplicate,
  editFormTab,
  setEditFormTab,
  editDataInLanguage,
  setEditDataInLanguage,
  editDataInEntries,
  setEditDataInEntries,
  editDataInRaw,
  setEditDataInRaw,
  editDataInRawError,
  setEditDataInRawError,
  editKeyInputs,
  setEditKeyInputs,
  editTitleInputs,
  setEditTitleInputs,
  editValueInputs,
  setEditValueInputs,
  handleEditFieldChange,
  handleEditSubmit,
  jsonFieldLanguage,
  setJsonFieldLanguage,
  priceInputs,
  setPriceInputs,
  objectToEntries,
  getUniqueBaseKeys,
  getTitleAndValueForLanguage,
  updateTitleAndValueForLanguage,
}: DataTableFormDialogProps) {
  const state = { collection, search }
  
  // State for roles (only for users collection)
  const [roles, setRoles] = React.useState<Array<{ uuid: string; title: string | null; name: string | null; isSystem: boolean | null }>>([])
  const [rolesLoading, setRolesLoading] = React.useState(false)
  const [rolePopoverOpen, setRolePopoverOpen] = React.useState(false)
  
  // Load roles when editing users
  React.useEffect(() => {
    if (state.collection === 'users' && editOpen) {
      const fetchRoles = async () => {
        try {
          setRolesLoading(true)
          const response = await fetch('/api/altrp/v1/admin/roles', {
            credentials: 'include',
          })
          if (response.ok) {
            const data = await response.json() as { docs?: Array<{ uuid: string; title: string | null; name: string | null; isSystem: boolean | null }> }
            if (Array.isArray(data.docs)) {
              setRoles(data.docs)
            }
          }
        } catch (err) {
          console.error('Failed to fetch roles:', err)
        } finally {
          setRolesLoading(false)
        }
      }
      fetchRoles()
    }
  }, [state.collection, editOpen])
  
  // Load user roles when recordToEdit changes
  React.useEffect(() => {
    if (state.collection === 'users' && recordToEdit && editOpen) {
      // Fetch user with roles
      const fetchUserRoles = async () => {
        try {
          const userUuid = recordToEdit.uuid
          if (userUuid) {
            const response = await fetch(`/api/altrp/v1/admin/users/${userUuid}`, {
              credentials: 'include',
            })
            if (response.ok) {
              const data = await response.json() as { success?: boolean; user?: { roles?: Array<{ uuid: string }> } }
              if (data.success && data.user?.roles) {
                const roleUuids = data.user.roles.map((r: { uuid: string }) => r.uuid)
                setEditData((prev) => ({ ...prev, roleUuids }))
              }
            }
          }
        } catch (err) {
          console.error('Failed to fetch user roles:', err)
        }
      }
      fetchUserRoles()
    }
  }, [state.collection, recordToEdit, editOpen, setEditData])
  
  // Helper function to extract role title/label
  const getRoleLabel = React.useCallback((role: { title: string | null | object; name: string | null }) => {
    if (role.title) {
      let title: any
      if (typeof role.title === 'string') {
        try {
          title = JSON.parse(role.title)
        } catch {
          title = role.title
        }
      } else {
        title = role.title
      }
      if (typeof title === 'object' && title !== null) {
        return title[locale] || title.en || title.ru || title.rs || role.name || 'Роль'
      } else {
        return String(title) || role.name || 'Роль'
      }
    }
    return role.name || 'Роль'
  }, [locale])
  
  const selectedRoles = roles.filter((role) => (editData.roleUuids || []).includes(role.uuid))

  return (
    <>
      <ResponsiveDialog
        open={createOpen}
        onOpenChange={(open) => {
          setCreateOpen(open)
          if (!open) {
            // Clear form data and price inputs when dialog closes
            setFormData({})
            setCreateError(null)
            setCreateFormTab("main")
            setCreateDataInLanguage(locale)
            setCreateDataInEntries([])
            setCreateDataInRaw("{}")
            setCreateDataInRawError(null)
            setPriceInputs((prev) => {
              const newInputs = { ...prev }
              editableFields.forEach((field) => {
                if (field.fieldType === "price") {
                  delete newInputs[`create-${field.name}`]
                }
              })
              return newInputs
            })
          }
        }}
        onlyDrawer
        direction="right"
        handleOnly
      >
        <ResponsiveDialogContent className="h-[calc(100svh-16px)] w-[560px] max-w-[95vw] overflow-hidden p-0 text-foreground">
          <div className="flex h-full flex-col text-foreground">
            <div className="border-b px-6 py-4">
              <ResponsiveDialogHeader>
                <ResponsiveDialogTitle className="text-foreground">{t.addRecord.title.replace("{collection}", collectionLabel)}</ResponsiveDialogTitle>
                <ResponsiveDialogDescription className="text-muted-foreground">
                  {t.addRecord.description}
                </ResponsiveDialogDescription>
              </ResponsiveDialogHeader>
            </div>
            <form onSubmit={handleCreateSubmit} className="flex min-h-0 flex-1 flex-col text-foreground">
              <div className="min-h-0 flex-1 overflow-y-auto px-6 py-4 text-foreground">
                <Tabs value={createFormTab} onValueChange={(v) => setCreateFormTab(v as any)} className="w-full">
                  <TabsList className="mb-4">
                    <TabsTrigger value="main">{t.tabs?.main || "Main"}</TabsTrigger>
                    {state.collection === "roles" && <TabsTrigger value="info">{t.tabs?.info || "Info"}</TabsTrigger>}
                    <TabsTrigger value="details">{t.tabs?.details || "Details"}</TabsTrigger>
                  </TabsList>
                  <TabsContent value="main" className="mt-0">
                    <div className="grid gap-4">
                      {editableFields.filter((f) => {
                        if (f.name === "data_in") return false
                        if (state.collection === "roles") {
                          // For roles, show: title, name, description, is_system, order, xaid
                          return ["title", "name", "description", "is_system", "order", "xaid"].includes(f.name)
                        }
                        if (state.collection === "expanses" && f.name === "xaid") {
                          // Hide xaid in expanses form (auto-generated)
                          return false
                        }
                        return true
                      }).map((field) => (
                        <div key={field.name} className="flex flex-col gap-2">
                          {field.fieldType === "boolean" ? (
                            <div className="flex items-center gap-2">
                              <Checkbox
                                id={`field-${field.name}`}
                                checked={formData[field.name] === true}
                                onCheckedChange={(checked) => handleFieldChange(field.name, checked === true)}
                              />
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium cursor-pointer">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                              </Label>
                            </div>
                          ) : field.fieldType === "date" || field.fieldType === "time" || field.fieldType === "datetime" ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <DateTimePicker
                                mode={field.fieldType}
                                value={formData[field.name] || null}
                                onChange={(date) => handleFieldChange(field.name, date)}
                                placeholder={t.form?.select?.replace("{field}", field.title || field.name) || `Select ${field.title || field.name}`}
                              />
                            </>
                          ) : field.fieldType === "phone" ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <PhoneInput
                                value={formData[field.name] || ""}
                                onChange={(value) => handleFieldChange(field.name, value || "")}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                              />
                            </>
                          ) : field.fieldType === "password" ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Input
                                id={`field-${field.name}`}
                                type="password"
                                required={!field.nullable}
                                value={formData[field.name] || ""}
                                onChange={(e) => handleFieldChange(field.name, e.target.value)}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                                minLength={8}
                              />
                              <Label htmlFor={`field-${field.name}-confirm`} className="text-sm font-medium">
                                {t.form?.confirm?.replace("{field}", field.title || field.name) || `Confirm ${field.title || field.name}`}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Input
                                id={`field-${field.name}-confirm`}
                                type="password"
                                required={!field.nullable}
                                value={formData[`${field.name}_confirm`] || ""}
                                onChange={(e) => handleFieldChange(`${field.name}_confirm`, e.target.value)}
                                placeholder={t.form?.confirm?.replace("{field}", field.title || field.name) || `Confirm ${field.title || field.name}`}
                                minLength={8}
                              />
                              {formData[field.name] && formData[`${field.name}_confirm`] && formData[field.name] !== formData[`${field.name}_confirm`] && (
                                <p className="text-sm text-destructive">{t.form?.passwordsDoNotMatch || "Passwords do not match"}</p>
                              )}
                            </>
                          ) : field.fieldType === "json" && getI18nJsonFieldsForCollection(state.collection).includes(field.name) ? (
                            <>
                              <div className="flex items-center justify-between">
                                <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                  {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                  {!field.nullable && <span className="text-destructive ml-1">*</span>}
                                </Label>
                                <Tabs
                                  value={jsonFieldLanguage[field.name] || locale}
                                  onValueChange={(value) => setJsonFieldLanguage((prev) => ({ ...prev, [field.name]: value as LanguageCode }))}
                                  className="w-auto"
                                >
                                  <TabsList className="h-8">
                                    {LANGUAGES.filter((l) => enabledLanguageCodes.includes(l.code)).map((l) => (
                                      <TabsTrigger key={l.code} value={l.code} className="text-xs px-2 py-1">
                                        {l.shortName}
                                      </TabsTrigger>
                                    ))}
                                  </TabsList>
                                </Tabs>
                              </div>
                              <Tabs
                                value={jsonFieldLanguage[field.name] || locale}
                                onValueChange={(value) => setJsonFieldLanguage((prev) => ({ ...prev, [field.name]: value as LanguageCode }))}
                                className="w-full"
                              >
                                {LANGUAGES.filter((l) => enabledLanguageCodes.includes(l.code)).map((l) => (
                                  <TabsContent key={l.code} value={l.code} className="mt-0">
                                    <Input
                                      id={`field-${field.name}_${l.code}`}
                                      type="text"
                                      required={!field.nullable}
                                      value={formData[`${field.name}_${l.code}`] || ""}
                                      onChange={(e) => handleFieldChange(`${field.name}_${l.code}`, e.target.value)}
                                      placeholder={
                                        t.form?.enter?.replace("{field}", `${field.title || field.name} (${l.name})`) ||
                                        `Enter ${field.title || field.name} (${l.name})`
                                      }
                                    />
                                  </TabsContent>
                                ))}
                              </Tabs>
                            </>
                          ) : (field as any).fieldType === "price" ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Input
                                id={`field-${field.name}`}
                                type="number"
                                inputMode="decimal"
                                step="0.01"
                                min="0"
                                required={!field.nullable}
                                value={
                                  priceInputs[`create-${field.name}`] !== undefined
                                    ? priceInputs[`create-${field.name}`]
                                    : formData[field.name] === undefined || formData[field.name] === null
                                      ? ""
                                      : (Number(formData[field.name]) / 100).toFixed(2)
                                }
                                onChange={(e) => {
                                  let v = e.target.value.replace(/,/g, ".")
                                  setPriceInputs((prev) => ({ ...prev, [`create-${field.name}`]: v }))
                                  if (v.includes(".")) {
                                    const [i, d] = v.split(".")
                                    v = `${i}.${d.slice(0, 2)}`
                                  }
                                  const num = v === "" ? NaN : Number(v)
                                  const cents = !isFinite(num) ? null : Math.round(num * 100)
                                  handleFieldChange(field.name, cents)
                                }}
                                onBlur={(e) => {
                                  let v = e.target.value.replace(/,/g, ".")
                                  if (v.includes(".")) {
                                    const [i, d] = v.split(".")
                                    v = `${i}.${d.slice(0, 2)}`
                                  }
                                  const num = v === "" ? NaN : Number(v)
                                  if (isFinite(num)) {
                                    const formatted = num.toFixed(2)
                                    setPriceInputs((prev) => ({ ...prev, [`create-${field.name}`]: formatted }))
                                    const cents = Math.round(num * 100)
                                    handleFieldChange(field.name, cents)
                                  }
                                }}
                                placeholder={`Enter ${field.title || field.name}`}
                              />
                            </>
                          ) : field.fieldType === "select" && field.selectOptions ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <ComboboxSelect
                                id={`field-${field.name}`}
                                options={field.selectOptions}
                                value={formData[field.name] || ""}
                                onValueChange={(value) => handleFieldChange(field.name, value)}
                                placeholder={t.form?.select?.replace("{field}", field.title || field.name) || `Select ${field.title || field.name}`}
                                disabled={false}
                                required={!field.nullable}
                                translations={t}
                              />
                            </>
                          ) : field.fieldType === "enum" && field.enum ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Select
                                value={formData[field.name] || ""}
                                onValueChange={(value) => handleFieldChange(field.name, value)}
                                required={!field.nullable}
                              >
                                <SelectTrigger>
                                  <SelectValue placeholder={`Select ${field.title || field.name}`} />
                                </SelectTrigger>
                                <SelectContent className="max-h-[300px] z-9999" position="popper" sideOffset={5}>
                                  {field.enum.values.map((val, index) => (
                                    <SelectItem key={val} value={val}>
                                      {field.enum!.labels[index] || val}
                                    </SelectItem>
                                  ))}
                                </SelectContent>
                              </Select>
                            </>
                          ) : field.relation ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <RelationSelect
                                relation={field.relation}
                                value={formData[field.name]}
                                onChange={(value) => handleFieldChange(field.name, value)}
                                required={!field.nullable}
                                translations={t}
                                search={state.search}
                              />
                            </>
                          ) : field.textarea ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Textarea
                                id={`field-${field.name}`}
                                required={!field.nullable}
                                value={formData[field.name] || ""}
                                onChange={(e) => handleFieldChange(field.name, e.target.value)}
                                placeholder={`Enter ${field.title || field.name}`}
                                rows={6}
                              />
                            </>
                          ) : field.name === "description" ? (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Textarea
                                id={`field-${field.name}`}
                                required={!field.nullable}
                                value={formData[field.name] || ""}
                                onChange={(e) => handleFieldChange(field.name, e.target.value)}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                                rows={4}
                              />
                            </>
                          ) : (
                            <>
                              <Label htmlFor={`field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Input
                                id={`field-${field.name}`}
                                type={field.fieldType === "email" ? "email" : field.fieldType === "number" ? "number" : "text"}
                                required={!field.nullable}
                                value={formData[field.name] || ""}
                                onChange={(e) => handleFieldChange(field.name, e.target.value)}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                              />
                            </>
                          )}
                        </div>
                      ))}
                    </div>
                  </TabsContent>
                  {state.collection === "roles" && (
                    <TabsContent value="info" className="mt-0">
                      <div className="grid gap-4">
                        {schema.filter((f) => ["id", "uuid", "order", "created_at", "updated_at"].includes(f.name)).map((field) => {
                          // For create form, these fields won't have values yet
                          const value = formData[field.name] ?? null
                          return (
                            <div key={field.name} className="flex flex-col gap-2">
                              <Label className="text-sm font-medium select-text">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                              </Label>
                              <div className="text-sm select-text">
                                {field.name === "created_at" || field.name === "updated_at" ? (
                                  <span className="select-text">
                                    {value ? formatDateTimeForLocale(value, locale) : "-"}
                                  </span>
                                ) : (
                                  <span className="select-text">
                                    {value ?? "-"}
                                  </span>
                                )}
                              </div>
                            </div>
                          )
                        })}
                      </div>
                    </TabsContent>
                  )}
                  <TabsContent value="details" className="mt-0">
                    <div className="grid gap-4">
                      {/* Language tabs */}
                      <div className="flex items-center justify-between">
                        <div className="text-sm font-medium">{t.editLanguage || "Language for editing"}</div>
                        <Tabs
                          value={createDataInLanguage}
                          onValueChange={(value) => setCreateDataInLanguage(value as LanguageCode)}
                          className="w-auto"
                        >
                          <TabsList className="h-8">
                            {LANGUAGES.filter((l) => enabledLanguageCodes.includes(l.code)).map((l) => (
                              <TabsTrigger key={l.code} value={l.code} className="text-xs px-2 py-1">
                                {l.shortName}
                              </TabsTrigger>
                            ))}
                          </TabsList>
                        </Tabs>
                      </div>

                      {/* Data_in fields */}
                      <div className="grid gap-4">
                        <div className="flex items-center justify-end">
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => {
                              // Add a new entry with a temporary unique key
                              const tempKey = `new_field_${Date.now()}`
                              setCreateDataInEntries((prev) => {
                                const newEntries = supportedLanguageCodes.map((lang) => ({
                                  key: `${tempKey}_${lang}`,
                                  title: "",
                                  value: "",
                                }))
                                return [...prev, ...newEntries]
                              })
                            }}
                          >
                            <IconPlus className="mr-2 h-4 w-4" />
                            {t.addField || "Add field"}
                          </Button>
                        </div>
                        <div className="grid gap-3">
                          {(() => {
                            const uniqueBaseKeys = getUniqueBaseKeys(createDataInEntries)
                            if (uniqueBaseKeys.length === 0) {
                              return <div className="text-sm text-muted-foreground">Нет полей</div>
                            }
                            return uniqueBaseKeys.map((baseKey, idx) => {
                              const { title: currentTitle, value: currentValue } = getTitleAndValueForLanguage(createDataInEntries, baseKey, createDataInLanguage)
                              const tempKey = createKeyInputs[baseKey] ?? baseKey
                              const tempTitle = createTitleInputs[baseKey] ?? currentTitle
                              const tempValue = createValueInputs[baseKey] ?? currentValue

                              return (
                                <div key={`create-entry-${baseKey}-${idx}`} className="flex gap-2 items-center">
                                  <Input
                                    value={tempKey}
                                    onChange={(e) => {
                                      const v = e.target.value
                                      // Update only the temporary state, don't update entries yet
                                      setCreateKeyInputs((prev) => ({
                                        ...prev,
                                        [baseKey]: v,
                                      }))
                                    }}
                                    onBlur={(e) => {
                                      const v = e.target.value.trim()
                                      if (!v || v === baseKey) {
                                        // Reset to original if empty or unchanged
                                        setCreateKeyInputs((prev) => {
                                          const newState = { ...prev }
                                          delete newState[baseKey]
                                          return newState
                                        })
                                        return
                                      }
                                      // Update base key in all language entries
                                      setCreateDataInEntries((prev) => {
                                        const result: DataInEntry[] = []
                                        const oldData: Record<string, { title: string; value: string }> = {}

                                        // Collect old title and value for all languages
                                        supportedLanguageCodes.forEach((lang) => {
                                          const oldLangKey = `${baseKey}_${lang}`
                                          const oldEntry = prev.find((e) => e.key === oldLangKey)
                                          if (oldEntry) {
                                            oldData[lang] = { title: oldEntry.title, value: oldEntry.value }
                                          }
                                        })

                                        // Keep entries that don't match this base key
                                        prev.forEach((entry) => {
                                          const langMatch = entry.key.match(/^(.+)_([a-z]{2})$/i)
                                          if (langMatch && langMatch[1] === baseKey) {
                                            return // Skip old entries for this base key
                                          }
                                          if (entry.key === baseKey) {
                                            return // Skip old entry without language suffix
                                          }
                                          result.push(entry)
                                        })

                                        // Add new entries with new base key
                                        supportedLanguageCodes.forEach((lang) => {
                                          result.push({
                                            key: `${v}_${lang}`,
                                            title: oldData[lang]?.title || "",
                                            value: oldData[lang]?.value || "",
                                          })
                                        })

                                        // Update temp key state with new base key
                                        setCreateKeyInputs((prev) => {
                                          const newState = { ...prev }
                                          delete newState[baseKey]
                                          newState[v] = v
                                          return newState
                                        })

                                        return result
                                      })
                                    }}
                                    placeholder="Name (key)"
                                    className="flex-1"
                                  />
                                  <Input
                                    value={tempTitle}
                                    onChange={(e) => {
                                      const v = e.target.value
                                      // Update only temporary state, don't update entries yet
                                      setCreateTitleInputs((prev) => ({
                                        ...prev,
                                        [baseKey]: v,
                                      }))
                                    }}
                                    onBlur={(e) => {
                                      const v = e.target.value
                                      // Update title - duplicate to all languages if this is the first value entered
                                      setCreateDataInEntries((prev) => {
                                        const allEmpty = supportedLanguageCodes.every((l) => {
                                          const { value } = getTitleAndValueForLanguage(prev, baseKey, l as LanguageCode)
                                          return !value || value.trim() === ""
                                        })

                                        const currentData = getTitleAndValueForLanguage(prev, baseKey, createDataInLanguage)
                                        return updateTitleAndValueForLanguage(prev, baseKey, createDataInLanguage, v, currentData.value, allEmpty && currentData.value.trim() !== "")
                                      })
                                      // Clear temp state
                                      setCreateTitleInputs((prev) => {
                                        const newState = { ...prev }
                                        delete newState[baseKey]
                                        return newState
                                      })
                                    }}
                                    placeholder="Title"
                                    className="flex-1"
                                  />
                                  <Input
                                    value={tempValue}
                                    onChange={(e) => {
                                      const v = e.target.value
                                      // Update only temporary state, don't update entries yet
                                      setCreateValueInputs((prev) => ({
                                        ...prev,
                                        [baseKey]: v,
                                      }))
                                    }}
                                    onBlur={(e) => {
                                      const v = e.target.value
                                      // Update value - duplicate to all languages if this is the first value entered
                                      setCreateDataInEntries((prev) => {
                                        // Check if this is the first value (all languages are empty)
                                        const allEmpty = supportedLanguageCodes.every((l) => {
                                          const { value } = getTitleAndValueForLanguage(prev, baseKey, l as LanguageCode)
                                          return !value || value.trim() === ""
                                        })

                                        const currentData = getTitleAndValueForLanguage(prev, baseKey, createDataInLanguage)
                                        return updateTitleAndValueForLanguage(prev, baseKey, createDataInLanguage, currentData.title, v, allEmpty && v.trim() !== "")
                                      })
                                      // Clear temp state
                                      setCreateValueInputs((prev) => {
                                        const newState = { ...prev }
                                        delete newState[baseKey]
                                        return newState
                                      })
                                    }}
                                    placeholder={(translations as any)?.dataTable?.valuePlaceholder || "Value (string or JSON)"}
                                    className="flex-1"
                                  />
                                  <Button
                                    type="button"
                                    variant="outline"
                                    size="icon"
                                    onClick={(e) => {
                                      e.preventDefault()
                                      e.stopPropagation()
                                      // Remove all entries for this base key
                                      setCreateDataInEntries((prev) => {
                                        return prev.filter((entry) => {
                                          const langMatch = entry.key.match(/^(.+)_([a-z]{2})$/i)
                                          if (langMatch && langMatch[1] === baseKey) {
                                            return false
                                          }
                                          return entry.key !== baseKey
                                        })
                                      })
                                    }}
                                  >
                                    <IconX className="h-4 w-4" />
                                    <span className="sr-only">Remove</span>
                                  </Button>
                                </div>
                              )
                            })
                          })()}
                        </div>
                      </div>

                      {/* Raw JSON */}
                      <div className="grid gap-2">
                        <div className="flex items-center justify-between">
                          <div className="text-sm font-medium">Raw JSON</div>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => {
                              void copyToClipboard(createDataInRaw || "")
                            }}
                          >
                            <IconCopy className="mr-2 h-4 w-4" />
                            {t.copy || "Копировать"}
                          </Button>
                        </div>
                        <Textarea
                          value={createDataInRaw}
                          onChange={(e) => setCreateDataInRaw(e.target.value)}
                          className="font-mono text-xs"
                          rows={10}
                        />
                        {createDataInRawError ? (
                          <div className="text-sm text-destructive">{createDataInRawError}</div>
                        ) : null}
                        <div className="flex justify-end">
                          <Button
                            type="button"
                            variant="outline"
                            onClick={() => {
                              try {
                                const parsed = JSON.parse(createDataInRaw || "{}")
                                setCreateDataInEntries(objectToEntries(parsed))
                                setCreateDataInRawError(null)
                              } catch (e) {
                                setCreateDataInRawError(e instanceof Error ? e.message : String(e))
                              }
                            }}
                          >
                            {t.applyJson || "Apply JSON"}
                          </Button>
                        </div>
                      </div>
                    </div>
                  </TabsContent>
                </Tabs>
                {createError && (
                  <div className="mt-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-sm text-destructive">
                    {createError}
                  </div>
                )}
              </div>
              <div className="border-t px-6 py-4">
                <ResponsiveDialogFooter className="m-0">
                  <Button type="button" variant="outline" onClick={() => setCreateOpen(false)}>
                    {t.form?.cancel || "Cancel"}
                  </Button>
                  <Button type="submit">{t.form?.create || "Create"}</Button>
                </ResponsiveDialogFooter>
              </div>
            </form>
            <ResponsiveDialogClose className="sr-only" />
          </div>
        </ResponsiveDialogContent>
      </ResponsiveDialog>

      <ResponsiveDialog
        open={editOpen}
        onOpenChange={(open) => {
          setEditOpen(open)
          if (!open) {
            // Clear edit data and price inputs when dialog closes
            setEditData({})
            setEditError(null)
            setRecordToEdit(null)
            setIsDuplicate(false)
            setEditFormTab("main")
            setEditDataInLanguage(locale)
            setEditDataInEntries([])
            setEditDataInRaw("{}")
            setEditDataInRawError(null)
            setPriceInputs((prev) => {
              const newInputs = { ...prev }
              schema.filter((f) => !isAutoGeneratedField(f.name, !!f.relation) && !f.primary && !f.hidden).forEach((field) => {
                if (field.fieldType === "price") {
                  delete newInputs[`edit-${field.name}`]
                }
              })
              return newInputs
            })
          }
        }}
        onlyDrawer
        direction="right"
        handleOnly
      >
        <ResponsiveDialogContent className="h-[calc(100svh-16px)] w-[560px] max-w-[95vw] overflow-hidden p-0 text-foreground">
          <div className="flex h-full flex-col text-foreground">
            <div className="border-b px-6 py-4">
              <ResponsiveDialogHeader>
                <ResponsiveDialogTitle className="text-foreground">
                  {isDuplicate
                    ? (t.createRecord?.title || "Create record in {collection}").replace("{collection}", collectionLabel)
                    : (t.editRecord?.title || "Edit record in {collection}").replace("{collection}", collectionLabel)
                  }
                </ResponsiveDialogTitle>
                <ResponsiveDialogDescription className="text-muted-foreground">
                  {isDuplicate
                    ? (t.createRecord?.description || "Fill in the fields below. Auto-generated fields are not editable and hidden.")
                    : (t.editRecord?.description || "Change fields below. Auto-generated fields are not editable and hidden.")
                  }
                </ResponsiveDialogDescription>
              </ResponsiveDialogHeader>
            </div>
            <form onSubmit={handleEditSubmit} className="flex min-h-0 flex-1 flex-col text-foreground">
              <div className="min-h-0 flex-1 overflow-y-auto px-6 py-4 text-foreground">
                <Tabs value={editFormTab} onValueChange={(v) => setEditFormTab(v as any)} className="w-full">
                  <TabsList className="mb-4">
                    <TabsTrigger value="main">{t.tabs?.main || "Main"}</TabsTrigger>
                    {state.collection === "roles" && <TabsTrigger value="info">{t.tabs?.info || "Info"}</TabsTrigger>}
                    <TabsTrigger value="details">{t.tabs?.details || "Details"}</TabsTrigger>
                  </TabsList>
                  <TabsContent value="main" className="mt-0">
                    <div className="grid gap-4">
                      {schema.filter((f) => {
                        if (!isAutoGeneratedField(f.name, !!f.relation) && !f.primary && !f.hidden && f.name !== "data_in") {
                          if (state.collection === "roles") {
                            // For roles, show: title, name, description, is_system, order, xaid
                            return ["title", "name", "description", "is_system", "order", "xaid"].includes(f.name)
                          }
                          return true
                        }
                        return false
                      }).map((field) => (
                        <div key={field.name} className="flex flex-col gap-2">
                          {field.fieldType === "boolean" ? (
                            <div className="flex items-center gap-2">
                              <Checkbox
                                id={`edit-field-${field.name}`}
                                checked={editData[field.name] === true}
                                onCheckedChange={(checked) => handleEditFieldChange(field.name, checked === true)}
                                disabled={field.readOnly}
                              />
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium cursor-pointer">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                              </Label>
                            </div>
                          ) : field.fieldType === "date" || field.fieldType === "time" || field.fieldType === "datetime" ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <DateTimePicker
                                mode={field.fieldType}
                                value={editData[field.name] || null}
                                onChange={(date) => handleEditFieldChange(field.name, date)}
                                placeholder={t.form?.select?.replace("{field}", field.title || field.name) || `Select ${field.title || field.name}`}
                                disabled={field.readOnly}
                              />
                            </>
                          ) : field.fieldType === "phone" ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <PhoneInput
                                value={editData[field.name] || ""}
                                onChange={(value) => handleEditFieldChange(field.name, value || "")}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                                disabled={field.readOnly}
                              />
                            </>
                          ) : field.fieldType === "password" ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {field.title || field.name} (leave empty to keep current)
                              </Label>
                              <Input
                                id={`edit-field-${field.name}`}
                                type="password"
                                value={editData[field.name] || ""}
                                onChange={(e) => handleEditFieldChange(field.name, e.target.value)}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                                minLength={8}
                                disabled={field.readOnly}
                              />
                              <Label htmlFor={`edit-field-${field.name}-confirm`} className="text-sm font-medium">
                                {t.form?.confirm?.replace("{field}", field.title || field.name) || `Confirm ${field.title || field.name}`}
                              </Label>
                              <Input
                                id={`edit-field-${field.name}-confirm`}
                                type="password"
                                value={editData[`${field.name}_confirm`] || ""}
                                onChange={(e) => handleEditFieldChange(`${field.name}_confirm`, e.target.value)}
                                placeholder={t.form?.confirm?.replace("{field}", field.title || field.name) || `Confirm ${field.title || field.name}`}
                                minLength={8}
                                disabled={field.readOnly}
                              />
                              {editData[field.name] && editData[`${field.name}_confirm`] && editData[field.name] !== editData[`${field.name}_confirm`] && (
                                <p className="text-sm text-destructive">{t.form?.passwordsDoNotMatch || "Passwords do not match"}</p>
                              )}
                            </>
                          ) : field.fieldType === "json" && getI18nJsonFieldsForCollection(state.collection).includes(field.name) ? (
                            <>
                              <div className="flex items-center justify-between">
                                <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                  {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                  {!field.nullable && <span className="text-destructive ml-1">*</span>}
                                </Label>
                                <Tabs
                                  value={jsonFieldLanguage[field.name] || locale}
                                  onValueChange={(value) => setJsonFieldLanguage((prev) => ({ ...prev, [field.name]: value as LanguageCode }))}
                                  className="w-auto"
                                >
                                  <TabsList className="h-8">
                                    {LANGUAGES.filter((l) => enabledLanguageCodes.includes(l.code)).map((l) => (
                                      <TabsTrigger key={l.code} value={l.code} className="text-xs px-2 py-1">
                                        {l.shortName}
                                      </TabsTrigger>
                                    ))}
                                  </TabsList>
                                </Tabs>
                              </div>
                              <Tabs
                                value={jsonFieldLanguage[field.name] || locale}
                                onValueChange={(value) => setJsonFieldLanguage((prev) => ({ ...prev, [field.name]: value as LanguageCode }))}
                                className="w-full"
                              >
                                {LANGUAGES.filter((l) => enabledLanguageCodes.includes(l.code)).map((l) => (
                                  <TabsContent key={l.code} value={l.code} className="mt-0">
                                    <Input
                                      id={`edit-field-${field.name}_${l.code}`}
                                      type="text"
                                      required={!field.nullable}
                                      value={editData[`${field.name}_${l.code}`] || ""}
                                      onChange={(e) => handleEditFieldChange(`${field.name}_${l.code}`, e.target.value)}
                                      placeholder={
                                        t.form?.enter?.replace("{field}", `${field.title || field.name} (${l.name})`) ||
                                        `Enter ${field.title || field.name} (${l.name})`
                                      }
                                    />
                                  </TabsContent>
                                ))}
                              </Tabs>
                            </>
                          ) : (field as any).fieldType === "price" ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Input
                                id={`edit-field-${field.name}`}
                                type="number"
                                inputMode="decimal"
                                step="0.01"
                                min="0"
                                required={!field.nullable}
                                value={
                                  priceInputs[`edit-${field.name}`] !== undefined
                                    ? priceInputs[`edit-${field.name}`]
                                    : editData[field.name] === undefined || editData[field.name] === null
                                      ? ""
                                      : (Number(editData[field.name]) / 100).toFixed(2)
                                }
                                onChange={(e) => {
                                  let v = e.target.value.replace(/,/g, ".")
                                  setPriceInputs((prev) => ({ ...prev, [`edit-${field.name}`]: v }))
                                  if (v.includes(".")) {
                                    const [i, d] = v.split(".")
                                    v = `${i}.${d.slice(0, 2)}`
                                  }
                                  const num = v === "" ? NaN : Number(v)
                                  const cents = !isFinite(num) ? null : Math.round(num * 100)
                                  handleEditFieldChange(field.name, cents)
                                }}
                                onBlur={(e) => {
                                  let v = e.target.value.replace(/,/g, ".")
                                  if (v.includes(".")) {
                                    const [i, d] = v.split(".")
                                    v = `${i}.${d.slice(0, 2)}`
                                  }
                                  const num = v === "" ? NaN : Number(v)
                                  if (isFinite(num)) {
                                    const formatted = num.toFixed(2)
                                    setPriceInputs((prev) => ({ ...prev, [`edit-${field.name}`]: formatted }))
                                    const cents = Math.round(num * 100)
                                    handleEditFieldChange(field.name, cents)
                                  }
                                }}
                                placeholder={`Enter ${field.title || field.name}`}
                                disabled={field.readOnly}
                              />
                            </>
                          ) : field.fieldType === "select" && field.selectOptions ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <ComboboxSelect
                                id={`edit-field-${field.name}`}
                                options={field.selectOptions}
                                value={editData[field.name] || ""}
                                onValueChange={(value) => handleEditFieldChange(field.name, value)}
                                placeholder={t.form?.select?.replace("{field}", field.title || field.name) || `Select ${field.title || field.name}`}
                                disabled={field.readOnly}
                                required={!field.nullable}
                                translations={t}
                              />
                            </>
                          ) : field.fieldType === "enum" && field.enum ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Select
                                value={editData[field.name] || ""}
                                onValueChange={(value) => handleEditFieldChange(field.name, value)}
                                required={!field.nullable}
                              >
                                <SelectTrigger>
                                  <SelectValue placeholder={`Select ${field.title || field.name}`} />
                                </SelectTrigger>
                                <SelectContent className="max-h-[300px] z-9999" position="popper" sideOffset={5}>
                                  {field.enum.values.map((val, index) => (
                                    <SelectItem key={val} value={val}>
                                      {field.enum!.labels[index] || val}
                                    </SelectItem>
                                  ))}
                                </SelectContent>
                              </Select>
                            </>
                          ) : field.relation ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <RelationSelect
                                relation={field.relation}
                                value={editData[field.name]}
                                onChange={(value) => handleEditFieldChange(field.name, value)}
                                required={!field.nullable}
                                translations={t}
                                search={state.search}
                              />
                            </>
                          ) : field.textarea ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Textarea
                                id={`edit-field-${field.name}`}
                                required={!field.nullable}
                                value={editData[field.name] || ""}
                                onChange={(e) => handleEditFieldChange(field.name, e.target.value)}
                                placeholder={`Enter ${field.title || field.name}`}
                                rows={6}
                              />
                            </>
                          ) : field.name === "description" ? (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Textarea
                                id={`edit-field-${field.name}`}
                                required={!field.nullable}
                                value={editData[field.name] || ""}
                                onChange={(e) => handleEditFieldChange(field.name, e.target.value)}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                                rows={4}
                              />
                            </>
                          ) : (
                            <>
                              <Label htmlFor={`edit-field-${field.name}`} className="text-sm font-medium">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                                {!field.nullable && <span className="text-destructive ml-1">*</span>}
                              </Label>
                              <Input
                                id={`edit-field-${field.name}`}
                                type={field.fieldType === "email" ? "email" : field.fieldType === "number" ? "number" : "text"}
                                required={!field.nullable}
                                value={editData[field.name] || ""}
                                onChange={(e) => handleEditFieldChange(field.name, e.target.value)}
                                placeholder={t.form?.enter?.replace("{field}", field.title || field.name) || `Enter ${field.title || field.name}`}
                                disabled={field.readOnly}
                              />
                            </>
                          )}
                        </div>
                      ))}
                      
                      {/* Roles field for users collection */}
                      {state.collection === "users" && (
                        <div className="flex flex-col gap-2">
                          <Label>Роли</Label>
                          <Popover open={rolePopoverOpen} onOpenChange={setRolePopoverOpen}>
                            <PopoverTrigger asChild>
                              <Button
                                variant="outline"
                                role="combobox"
                                className="w-full justify-between"
                                aria-expanded={rolePopoverOpen}
                                disabled={rolesLoading}
                              >
                                <span className="truncate">
                                  {selectedRoles.length > 0
                                    ? selectedRoles.length === 1
                                      ? getRoleLabel(selectedRoles[0])
                                      : `Выбрано: ${selectedRoles.length}`
                                    : 'Выберите роли...'}
                                </span>
                                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                              </Button>
                            </PopoverTrigger>
                            <PopoverContent className="w-full p-0" align="start">
                              <Command>
                                <CommandInput placeholder="Поиск ролей..." />
                                <CommandList>
                                  <CommandEmpty>Роли не найдены</CommandEmpty>
                                  <CommandGroup>
                                    {roles.map((role) => {
                                      const isSelected = (editData.roleUuids || []).includes(role.uuid)
                                      const roleLabel = getRoleLabel(role)
                                      return (
                                        <CommandItem
                                          key={role.uuid}
                                          value={`${roleLabel} ${role.uuid}`}
                                          onSelect={() => {
                                            const currentRoleUuids = editData.roleUuids || []
                                            const newRoleUuids = isSelected
                                              ? currentRoleUuids.filter((id: string) => id !== role.uuid)
                                              : [...currentRoleUuids, role.uuid]
                                            handleEditFieldChange('roleUuids', newRoleUuids)
                                          }}
                                        >
                                          <Check
                                            className={cn(
                                              'mr-2 h-4 w-4',
                                              isSelected ? 'opacity-100' : 'opacity-0'
                                            )}
                                          />
                                          {roleLabel}
                                          {role.isSystem && (
                                            <Badge variant="secondary" className="ml-2">
                                              Системная
                                            </Badge>
                                          )}
                                        </CommandItem>
                                      )
                                    })}
                                  </CommandGroup>
                                </CommandList>
                              </Command>
                            </PopoverContent>
                          </Popover>
                          {selectedRoles.length > 0 && (
                            <div className="flex flex-wrap gap-2 mt-2">
                              {selectedRoles.map((role) => (
                                <Badge key={role.uuid} variant="secondary">
                                  {getRoleLabel(role)}
                                  <button
                                    type="button"
                                    onClick={() => {
                                      const currentRoleUuids = editData.roleUuids || []
                                      handleEditFieldChange('roleUuids', currentRoleUuids.filter((id: string) => id !== role.uuid))
                                    }}
                                    className="ml-2 hover:text-destructive"
                                  >
                                    ×
                                  </button>
                                </Badge>
                              ))}
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </TabsContent>
                  {state.collection === "roles" && (
                    <TabsContent value="info" className="mt-0">
                      <div className="grid gap-4">
                        {schema.filter((f) => ["id", "uuid", "order", "created_at", "updated_at"].includes(f.name)).map((field) => {
                          const value = editData[field.name] ?? null
                          return (
                            <div key={field.name} className="flex flex-col gap-2">
                              <Label className="text-sm font-medium select-text">
                                {(translations as any)?.dataTable?.fields?.[state.collection]?.[field.name] || field.title || field.name}
                              </Label>
                              <div className="text-sm select-text">
                                {field.name === "created_at" || field.name === "updated_at" ? (
                                  <span className="select-text">
                                    {value ? formatDateTimeForLocale(value, locale) : "-"}
                                  </span>
                                ) : (
                                  <span className="select-text">
                                    {value ?? "-"}
                                  </span>
                                )}
                              </div>
                            </div>
                          )
                        })}
                      </div>
                    </TabsContent>
                  )}
                  <TabsContent value="details" className="mt-0">
                    <div className="grid gap-4">
                      {/* Language tabs */}
                      <div className="flex items-center justify-between">
                        <div className="text-sm font-medium">{t.editLanguage || "Language for editing"}</div>
                        <Tabs
                          value={editDataInLanguage}
                          onValueChange={(value) => setEditDataInLanguage(value as LanguageCode)}
                          className="w-auto"
                        >
                          <TabsList className="h-8">
                            {LANGUAGES.filter((l) => enabledLanguageCodes.includes(l.code)).map((l) => (
                              <TabsTrigger key={l.code} value={l.code} className="text-xs px-2 py-1">
                                {l.shortName}
                              </TabsTrigger>
                            ))}
                          </TabsList>
                        </Tabs>
                      </div>

                      {/* Data_in fields */}
                      <div className="grid gap-4">
                        <div className="flex items-center justify-end">
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => {
                              // Add a new entry with a temporary unique key
                              const tempKey = `new_field_${Date.now()}`
                              setEditDataInEntries((prev) => {
                                const newEntries = supportedLanguageCodes.map((lang) => ({
                                  key: `${tempKey}_${lang}`,
                                  title: "",
                                  value: "",
                                }))
                                return [...prev, ...newEntries]
                              })
                            }}
                          >
                            <IconPlus className="mr-2 h-4 w-4" />
                            {t.addField || "Add field"}
                          </Button>
                        </div>
                        <div className="grid gap-3">
                          {(() => {
                            const uniqueBaseKeys = getUniqueBaseKeys(editDataInEntries)
                            if (uniqueBaseKeys.length === 0) {
                              return <div className="text-sm text-muted-foreground">Нет полей</div>
                            }
                            return uniqueBaseKeys.map((baseKey, idx) => {
                              const { title: currentTitle, value: currentValue } = getTitleAndValueForLanguage(editDataInEntries, baseKey, editDataInLanguage)
                              const tempKey = editKeyInputs[baseKey] ?? baseKey
                              const tempTitle = editTitleInputs[baseKey] ?? currentTitle
                              const tempValue = editValueInputs[baseKey] ?? currentValue

                              return (
                                <div key={`edit-entry-${baseKey}-${idx}`} className="flex gap-2 items-center">
                                  <Input
                                    value={tempKey}
                                    onChange={(e) => {
                                      const v = e.target.value
                                      // Update only the temporary state, don't update entries yet
                                      setEditKeyInputs((prev) => ({
                                        ...prev,
                                        [baseKey]: v,
                                      }))
                                    }}
                                    onBlur={(e) => {
                                      const v = e.target.value.trim()
                                      if (!v || v === baseKey) {
                                        // Reset to original if empty or unchanged
                                        setEditKeyInputs((prev) => {
                                          const newState = { ...prev }
                                          delete newState[baseKey]
                                          return newState
                                        })
                                        return
                                      }
                                      // Update base key in all language entries
                                      setEditDataInEntries((prev) => {
                                        const result: DataInEntry[] = []
                                        const oldData: Record<string, { title: string; value: string }> = {}

                                        // Collect old title and value for all languages
                                        supportedLanguageCodes.forEach((lang) => {
                                          const oldLangKey = `${baseKey}_${lang}`
                                          const oldEntry = prev.find((e) => e.key === oldLangKey)
                                          if (oldEntry) {
                                            oldData[lang] = { title: oldEntry.title, value: oldEntry.value }
                                          }
                                        })

                                        // Keep entries that don't match this base key
                                        prev.forEach((entry) => {
                                          const langMatch = entry.key.match(/^(.+)_([a-z]{2})$/i)
                                          if (langMatch && langMatch[1] === baseKey) {
                                            return // Skip old entries for this base key
                                          }
                                          if (entry.key === baseKey) {
                                            return // Skip old entry without language suffix
                                          }
                                          result.push(entry)
                                        })

                                        // Add new entries with new base key
                                        supportedLanguageCodes.forEach((lang) => {
                                          result.push({
                                            key: `${v}_${lang}`,
                                            title: oldData[lang]?.title || "",
                                            value: oldData[lang]?.value || "",
                                          })
                                        })

                                        // Update temp key state with new base key
                                        setEditKeyInputs((prev) => {
                                          const newState = { ...prev }
                                          delete newState[baseKey]
                                          newState[v] = v
                                          return newState
                                        })

                                        return result
                                      })
                                    }}
                                    placeholder="Name (key)"
                                    className="flex-1"
                                  />
                                  <Input
                                    value={tempTitle}
                                    onChange={(e) => {
                                      const v = e.target.value
                                      // Update only temporary state, don't update entries yet
                                      setEditTitleInputs((prev) => ({
                                        ...prev,
                                        [baseKey]: v,
                                      }))
                                    }}
                                    onBlur={(e) => {
                                      const v = e.target.value
                                      // Update title - duplicate to all languages if this is the first value entered
                                      setEditDataInEntries((prev) => {
                                        const allEmpty = supportedLanguageCodes.every((l) => {
                                          const { value } = getTitleAndValueForLanguage(prev, baseKey, l as LanguageCode)
                                          return !value || value.trim() === ""
                                        })

                                        const currentData = getTitleAndValueForLanguage(prev, baseKey, editDataInLanguage)
                                        return updateTitleAndValueForLanguage(prev, baseKey, editDataInLanguage, v, currentData.value, allEmpty && currentData.value.trim() !== "")
                                      })
                                      // Clear temp state
                                      setEditTitleInputs((prev) => {
                                        const newState = { ...prev }
                                        delete newState[baseKey]
                                        return newState
                                      })
                                    }}
                                    placeholder="Title"
                                    className="flex-1"
                                  />
                                  <Input
                                    value={tempValue}
                                    onChange={(e) => {
                                      const v = e.target.value
                                      // Update only temporary state, don't update entries yet
                                      setEditValueInputs((prev) => ({
                                        ...prev,
                                        [baseKey]: v,
                                      }))
                                    }}
                                    onBlur={(e) => {
                                      const v = e.target.value
                                      // Update value - duplicate to all languages if this is the first value entered
                                      setEditDataInEntries((prev) => {
                                        // Check if this is the first value (all languages are empty)
                                        const allEmpty = supportedLanguageCodes.every((l) => {
                                          const { value } = getTitleAndValueForLanguage(prev, baseKey, l as LanguageCode)
                                          return !value || value.trim() === ""
                                        })

                                        const currentData = getTitleAndValueForLanguage(prev, baseKey, editDataInLanguage)
                                        return updateTitleAndValueForLanguage(prev, baseKey, editDataInLanguage, currentData.title, v, allEmpty && v.trim() !== "")
                                      })
                                      // Clear temp state
                                      setEditValueInputs((prev) => {
                                        const newState = { ...prev }
                                        delete newState[baseKey]
                                        return newState
                                      })
                                    }}
                                    placeholder={(translations as any)?.dataTable?.valuePlaceholder || "Value (string or JSON)"}
                                    className="flex-1"
                                  />
                                  <Button
                                    type="button"
                                    variant="outline"
                                    size="icon"
                                    onClick={(e) => {
                                      e.preventDefault()
                                      e.stopPropagation()
                                      // Remove all entries for this base key
                                      setEditDataInEntries((prev) => {
                                        return prev.filter((entry) => {
                                          const langMatch = entry.key.match(/^(.+)_([a-z]{2})$/i)
                                          if (langMatch && langMatch[1] === baseKey) {
                                            return false
                                          }
                                          return entry.key !== baseKey
                                        })
                                      })
                                    }}
                                  >
                                    <IconX className="h-4 w-4" />
                                    <span className="sr-only">Remove</span>
                                  </Button>
                                </div>
                              )
                            })
                          })()}
                        </div>
                      </div>

                      {/* Raw JSON */}
                      <div className="grid gap-2">
                        <div className="flex items-center justify-between">
                          <div className="text-sm font-medium">Raw JSON</div>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => {
                              void copyToClipboard(editDataInRaw || "")
                            }}
                          >
                            <IconCopy className="mr-2 h-4 w-4" />
                            {t.copy || "Копировать"}
                          </Button>
                        </div>
                        <Textarea
                          value={editDataInRaw}
                          onChange={(e) => setEditDataInRaw(e.target.value)}
                          className="font-mono text-xs"
                          rows={10}
                        />
                        {editDataInRawError ? (
                          <div className="text-sm text-destructive">{editDataInRawError}</div>
                        ) : null}
                        <div className="flex justify-end">
                          <Button
                            type="button"
                            variant="outline"
                            onClick={() => {
                              try {
                                const parsed = JSON.parse(editDataInRaw || "{}")
                                setEditDataInEntries(objectToEntries(parsed))
                                setEditDataInRawError(null)
                              } catch (e) {
                                setEditDataInRawError(e instanceof Error ? e.message : String(e))
                              }
                            }}
                          >
                            {t.applyJson || "Apply JSON"}
                          </Button>
                        </div>
                      </div>
                    </div>
                  </TabsContent>
                </Tabs>
                {editError && (
                  <div className="mt-4 rounded-lg border border-destructive/50 bg-destructive/10 p-3 text-sm text-destructive">
                    {editError}
                  </div>
                )}
              </div>
              <div className="border-t px-6 py-4">
                <ResponsiveDialogFooter className="m-0">
                  <Button type="button" variant="outline" onClick={() => setEditOpen(false)}>
                    {t.form?.cancel || "Cancel"}
                  </Button>
                  <Button type="submit">{isDuplicate ? (t.form?.create || "Create") : (t.form?.save || "Save")}</Button>
                </ResponsiveDialogFooter>
              </div>
            </form>
            <ResponsiveDialogClose className="sr-only" />
          </div>
        </ResponsiveDialogContent>
      </ResponsiveDialog>
    </>
  )
}
